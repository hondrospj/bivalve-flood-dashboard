
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bivalve, NJ — Tidal Flooding Dashboard</title>

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Time handling (Luxon) + Chart.js adapter -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --text:#eaf0ff;
      --muted:#a9b6d3;
      --line:rgba(255,255,255,.085);
      --card:linear-gradient(180deg, rgba(255,255,255,.060), rgba(255,255,255,.022));
      --card2:rgba(0,0,0,.18);
      --shadow:0 22px 70px rgba(0,0,0,.42);
      --radius:18px;

      --ok:#2dd4bf;
      --minor:#fbbf24;
      --moderate:#fb7185;
      --major:#a78bfa;

      --danger:#fb7185;
      --accent:#7aa7ff;
      --accent2:#a78bfa;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 650px at 12% 10%, rgba(122,167,255,.22), transparent 52%),
        radial-gradient(900px 600px at 92% 10%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(900px 650px at 50% 92%, rgba(45,212,191,.12), transparent 55%),
        var(--bg);
      color:var(--text);
    }

    a{color:inherit}
    .wrap{max-width:1260px; margin:0 auto; padding:22px 18px 38px}

    /* Top bar */
    .topbar{
      display:flex; align-items:flex-start; justify-content:space-between; gap:14px;
      margin-bottom:14px;
    }
    .title{
      display:flex; flex-direction:column; gap:6px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
    }

    .rightControls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      border-radius:999px;
      box-shadow:0 10px 30px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-size:12px;
      color:var(--muted);
    }
    .dot{
      width:8px; height:8px; border-radius:999px;
      background:var(--ok);
      box-shadow:0 0 0 6px rgba(45,212,191,.12);
      flex:none;
    }
    .dot.warn{background:var(--minor); box-shadow:0 0 0 6px rgba(251,191,36,.12);}
    .dot.danger{background:var(--danger); box-shadow:0 0 0 6px rgba(251,113,133,.12);}
    .dot.purple{background:var(--major); box-shadow:0 0 0 6px rgba(167,139,250,.12);}

    .btn{
      border:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:999px;
      font-weight:800;
      letter-spacing:.15px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:0 14px 40px rgba(0,0,0,.30);
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{transform:translateY(-1px); background:rgba(255,255,255,.085); border-color:rgba(255,255,255,.16);}
    .btn:active{transform:translateY(0px) scale(.99);}

    .btn.primary{
      background:linear-gradient(180deg, rgba(122,167,255,.26), rgba(122,167,255,.10));
      border-color: rgba(122,167,255,.28);
    }
    .btn.primary:hover{background:linear-gradient(180deg, rgba(122,167,255,.33), rgba(122,167,255,.13));}

    .btn.ghost{
      background:rgba(0,0,0,.18);
      border-color: rgba(255,255,255,.10);
    }

    /* Blinking flood stage indicator */
    .blink{
      position:relative;
      overflow:hidden;
    }
    .blink::after{
      content:"";
      position:absolute;
      inset:-60% -40%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.18), transparent 45%),
                  radial-gradient(circle at 70% 70%, rgba(255,255,255,.10), transparent 50%);
      opacity:.0;
      animation: pulseGlow 1.25s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes pulseGlow{
      0%{opacity:.0}
      45%{opacity:.35}
      100%{opacity:.0}
    }

    /* Cards grid */
    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      border:1px solid var(--line);
      background:var(--card);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .cardHeader{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.07);
      background:rgba(0,0,0,.10);
    }
    .cardHeader h2{
      margin:0;
      font-size:13px;
      font-weight:900;
      letter-spacing:.22px;
      text-transform:uppercase;
    }
    .cardHeader .meta{
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
      text-align:right;
    }

    .cardBody{padding:12px 14px 14px}

    /* Top stat tiles */
    .tiles{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 640px){
      .tiles{grid-template-columns:1fr}
    }
    .tile{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      border-radius:16px;
      padding:14px 14px;
      display:flex; justify-content:space-between; gap:10px;
      min-height:76px;
    }
    .tile .label{
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      letter-spacing:.2px;
    }
    .tile .value{
      font-size:26px;
      font-weight:950;
      letter-spacing:.2px;
      line-height:1.05;
      margin-top:6px;
    }
    .tile .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }
    .badge{
      padding:6px 9px;
      border-radius:999px;
      font-size:12px;
      font-weight:900;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      color:var(--text);
      align-self:flex-start;
      white-space:nowrap;
    }
    .badge.ok{border-color: rgba(45,212,191,.35); background: rgba(45,212,191,.10);}
    .badge.minor{border-color: rgba(251,191,36,.45); background: rgba(251,191,36,.11);}
    .badge.mod{border-color: rgba(251,113,133,.45); background: rgba(251,113,133,.10);}
    .badge.maj{border-color: rgba(167,139,250,.50); background: rgba(167,139,250,.12);}

    /* Chart canvas sizing */
    .chartBox{height:340px;}
    .chartBox.tall{height:380px;}
    canvas{width:100% !important; height:100% !important;}

    /* Tables */
    table{width:100%; border-collapse:collapse;}
    th,td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.07);
      font-size:12px;
      vertical-align:middle;
    }
    th{
      text-align:left;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.18px;
      text-transform:uppercase;
      font-size:11px;
    }
    tr:last-child td{border-bottom:none;}
    .rank{
      font-weight:950;
      font-size:12px;
      color:var(--text);
    }
    .muted{color:var(--muted)}
    .stageTag{
      display:inline-flex;
      align-items:center;
      gap:7px;
      font-weight:900;
      padding:6px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      white-space:nowrap;
    }
    .stageTag .miniDot{width:7px;height:7px;border-radius:999px;background:var(--ok)}
    .stageTag.minor .miniDot{background:var(--minor)}
    .stageTag.moderate .miniDot{background:var(--moderate)}
    .stageTag.major .miniDot{background:var(--major)}

    /* Inputs */
    .controlsRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:10px;
    }
    .input{
      flex:1 1 210px;
      min-width:210px;
      border-radius:14px;
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
      padding:10px 12px;
      outline:none;
      font-weight:700;
      font-size:13px;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
      margin-top:6px;
      line-height:1.35;
    }

    .footerNote{
      margin-top:14px;
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
      opacity:.95;
    }
    .kpiRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      margin-top:8px;
    }
    .kpi{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .kpi strong{color:var(--text)}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Bivalve, New Jersey — Tidal Flooding Dashboard</h1>
        <div class="subtitle">
          Datum-aware, auto-updating tidal flooding analytics (all times shown in <b>EST</b>).
        </div>

        <div class="tiles">
          <div class="tile">
            <div>
              <div class="label">Current Water Elevation</div>
              <div class="value" id="kpiNow">—</div>
              <div class="sub"><span class="muted">Updated:</span> <span id="kpiNowUpdated">—</span></div>
            </div>
            <div class="badge" id="kpiStageBadge">—</div>
          </div>

          <div class="tile">
            <div>
              <div class="label">Daily Range (Today)</div>
              <div class="value" id="kpiRange">—</div>
              <div class="sub"><span class="muted">Updated:</span> <span id="kpiRangeUpdated">—</span></div>
            </div>
            <div class="badge ghost" id="kpiRangeBadge">EST</div>
          </div>
        </div>
      </div>

      <div class="rightControls">
        <div class="pill" title="Last time the dashboard pulled and processed data">
          <span class="dot" id="dotFresh"></span>
          <span><span class="muted">Page updated:</span> <span id="pageUpdated">—</span></span>
        </div>

        <button class="btn ghost blink" id="btnStage" title="Current flood stage (blinks)">
          <span id="btnStageText">Stage: —</span>
        </button>

        <button class="btn primary" id="btnDatum" title="Flip all values between MLLW and NAVD88">
          <span id="btnDatumText">Datum: MLLW</span>
        </button>

        <button class="btn" id="btnRefresh" title="Force refresh now">
          Refresh
        </button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT COLUMN -->
      <div class="card">
        <div class="cardHeader">
          <h2>Observations vs Predictions</h2>
          <div class="meta">
            <span class="kpi"><strong>24h</strong> obs + <strong>72h</strong> fcst</span>
            <span class="kpi"><strong>Station</strong> USGS-01412150 + NWPS (bvvn4)</span>
          </div>
        </div>
        <div class="cardBody">
          <div class="chartBox tall">
            <canvas id="chartHydro"></canvas>
          </div>
          <div class="footerNote">
            Threshold lines show Minor / Moderate / Major flood stages (datum-aware). Observations come from USGS tidal elevation (NOS-averaged). Predictions come from NOAA/NWS NWPS hydrograph for <b>bvvn4</b>.
          </div>
        </div>
      </div>

      <!-- RIGHT COLUMN -->
      <div class="card">
        <div class="cardHeader">
          <h2>Top Ten Highest Tides</h2>
          <div class="meta">
            <span class="kpi"><strong>Auto-updates</strong> when a new top-10 tide occurs</span>
          </div>
        </div>
        <div class="cardBody">
          <table>
            <thead>
              <tr>
                <th style="width:56px;">Rank</th>
                <th>Elevation</th>
                <th>Stage</th>
                <th>Date (EST)</th>
              </tr>
            </thead>
            <tbody id="top10Body">
              <tr><td colspan="4" class="muted">Loading…</td></tr>
            </tbody>
          </table>
          <div class="hint">
            List is seeded from your provided historic set, then monitored using USGS observed tidal elevations for any new entries.
          </div>
        </div>
      </div>

      <!-- Historic flooding count -->
      <div class="card">
        <div class="cardHeader">
          <h2>Historic Flooding Count</h2>
          <div class="meta">
            <span class="kpi"><strong>2000–2025</strong> from <b>bivalve_daily_stats.txt</b></span>
            <span class="kpi"><strong>2026+</strong> from live USGS</span>
          </div>
        </div>
        <div class="cardBody">
          <div class="chartBox">
            <canvas id="chartAnnual"></canvas>
          </div>
          <div class="hint">
            Two floods can occur in one day. Post-2025 counts are computed from intraday peaks (up to 2) relative to Minor/Moderate/Major thresholds.
          </div>
        </div>
      </div>

      <!-- Monthly average flooding -->
      <div class="card">
        <div class="cardHeader">
          <h2>Monthly Average Flood Count</h2>
          <div class="meta">
            <span class="kpi"><strong>Hybrid</strong>: txt (2000–2025) + live (2026+)</span>
          </div>
        </div>
        <div class="cardBody">
          <div class="chartBox">
            <canvas id="chartMonthly"></canvas>
          </div>
          <div class="hint">
            Shows average number of floods per month of year (stacked by Minor/Moderate/Major).
          </div>
        </div>
      </div>

      <!-- Historical tide query -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="cardHeader">
          <h2>Query a Historical Tide</h2>
          <div class="meta">
            <span class="kpi"><strong>Hybrid lookup</strong>: txt archive + live USGS</span>
          </div>
        </div>
        <div class="cardBody">
          <div class="controlsRow">
            <input class="input" id="queryDate" placeholder="Date (YYYY-MM-DD) e.g., 2012-10-29" />
            <input class="input" id="queryTime" placeholder="Optional time (HH:MM) e.g., 20:15" />
            <button class="btn primary" id="btnQuery">Search</button>
            <button class="btn" id="btnQueryClear">Clear</button>
          </div>

          <div class="kpiRow" id="queryResultRow" style="display:none;">
            <div class="kpi"><strong>Result:</strong> <span id="queryResultValue">—</span></div>
            <div class="kpi"><strong>Stage:</strong> <span id="queryResultStage">—</span></div>
            <div class="kpi"><strong>Source:</strong> <span id="queryResultSource">—</span></div>
            <div class="kpi"><strong>Timestamp (EST):</strong> <span id="queryResultTs">—</span></div>
          </div>

          <div class="hint">
            Tip: If you provide only a date, the tool returns the highest tide for that day. If you include a time, it returns the nearest observation within that day.
          </div>
        </div>
      </div>
    </div>

    <div class="footerNote">
      <b>GitHub Pages notes:</b> Put <code>index.html</code> in your repo root. Also put your archive file <code>bivalve_daily_stats.txt</code> in the same folder (repo root) so the dashboard can fetch it with a relative path.
    </div>
  </div>

  <script>
/* ========= SCRIPT (Part 1/2) ========= */

/* Fixed EST year-round (UTC-5) as requested. */
const TZ = "Etc/GMT+5";
const { DateTime } = luxon;

/* ===== Datum relationship for Bivalve =====
   You said: MLLW is 3.41 ft HIGHER than NAVD.
   Therefore:
     MLLW = NAVD + 3.41
     NAVD = MLLW - 3.41
*/
const OFFSET_MLLW_MINUS_NAVD_FT = 3.41;

/* Thresholds provided in MLLW */
const THRESH_MLLW = {
  minor: 7.6,
  moderate: 8.6,
  major: 9.6
};

/* Display datum toggle (MLLW default) */
let DISPLAY_DATUM = "MLLW"; // "MLLW" | "NAVD88"

/* Sources */
const USGS_SITE = "01412150";
/* USGS parameter: 72279 = "Tidal elevation, NOS-averaged, NAVD88, feet" */
const USGS_PARAM_NAVD = "72279";

/* NWPS (NOAA/NWS) gauge id for water.noaa.gov hydrograph */
const NWPS_LID = "bvvn4";

/* Local archive file (must exist in repo root) */
const ARCHIVE_TXT_PATH = "bivalve_daily_stats.txt";

/* Refresh cadence */
const AUTO_REFRESH_MS = 5 * 60 * 1000; // 5 minutes

/* === Helpers: time, parsing, datum conversion === */
function nowEst(){
  return DateTime.now().setZone(TZ);
}
function fmtEst(dt){
  return dt.setZone(TZ).toFormat("LLL dd, yyyy • h:mm a") + " EST";
}
function fmtDateEst(dt){
  return dt.setZone(TZ).toFormat("yyyy-LL-dd");
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function isFiniteNumber(x){ return typeof x === "number" && Number.isFinite(x); }

/* Convert NAVD->MLLW and MLLW->NAVD */
function navdToMllw(ft_navd){ return ft_navd + OFFSET_MLLW_MINUS_NAVD_FT; }
function mllwToNavd(ft_mllw){ return ft_mllw - OFFSET_MLLW_MINUS_NAVD_FT; }

function toDisplayFromMllw(ft_mllw){
  if(!isFiniteNumber(ft_mllw)) return null;
  return (DISPLAY_DATUM === "MLLW") ? ft_mllw : mllwToNavd(ft_mllw);
}
function fromDisplayToMllw(ft_display){
  if(!isFiniteNumber(ft_display)) return null;
  return (DISPLAY_DATUM === "MLLW") ? ft_display : navdToMllw(ft_display);
}
function thresholdDisplay(which){
  const ft_mllw = THRESH_MLLW[which];
  return toDisplayFromMllw(ft_mllw);
}
function stageFromMllw(ft_mllw){
  if(!isFiniteNumber(ft_mllw)) return "—";
  if(ft_mllw >= THRESH_MLLW.major) return "major";
  if(ft_mllw >= THRESH_MLLW.moderate) return "moderate";
  if(ft_mllw >= THRESH_MLLW.minor) return "minor";
  return "none";
}
function stageLabel(stage){
  if(stage === "major") return "Major";
  if(stage === "moderate") return "Moderate";
  if(stage === "minor") return "Minor";
  return "No Flood";
}
function stageBadgeClass(stage){
  if(stage === "major") return "maj";
  if(stage === "moderate") return "mod";
  if(stage === "minor") return "minor";
  return "ok";
}
function stageDotClass(stage){
  if(stage === "major") return "purple";
  if(stage === "moderate") return "danger";
  if(stage === "minor") return "warn";
  return "";
}
function fmtFt(ft){
  if(!isFiniteNumber(ft)) return "—";
  return ft.toFixed(2) + " ft";
}

/* === DOM refs === */
const el = {
  pageUpdated: document.getElementById("pageUpdated"),
  dotFresh: document.getElementById("dotFresh"),
  btnStage: document.getElementById("btnStage"),
  btnStageText: document.getElementById("btnStageText"),
  btnDatum: document.getElementById("btnDatum"),
  btnDatumText: document.getElementById("btnDatumText"),
  btnRefresh: document.getElementById("btnRefresh"),

  kpiNow: document.getElementById("kpiNow"),
  kpiNowUpdated: document.getElementById("kpiNowUpdated"),
  kpiStageBadge: document.getElementById("kpiStageBadge"),
  kpiRange: document.getElementById("kpiRange"),
  kpiRangeUpdated: document.getElementById("kpiRangeUpdated"),

  top10Body: document.getElementById("top10Body"),

  queryDate: document.getElementById("queryDate"),
  queryTime: document.getElementById("queryTime"),
  btnQuery: document.getElementById("btnQuery"),
  btnQueryClear: document.getElementById("btnQueryClear"),
  queryResultRow: document.getElementById("queryResultRow"),
  queryResultValue: document.getElementById("queryResultValue"),
  queryResultStage: document.getElementById("queryResultStage"),
  queryResultSource: document.getElementById("queryResultSource"),
  queryResultTs: document.getElementById("queryResultTs"),
};

/* === Chart globals === */
let chartHydro = null;
let chartAnnual = null;
let chartMonthly = null;

/* === State containers === */
const STATE = {
  lastUpdate: null,

  /* Time series (stored internally in MLLW for consistency) */
  obs: [],   // [{t: DateTime, ft_mllw: number}]
  fcst: [],  // [{t: DateTime, ft_mllw: number}]

  /* Archive-derived annual counts and daily peaks */
  archiveDaily: [], // normalized daily stats from txt
  annualCounts: new Map(),  // year -> {minor,moderate,major}
  monthlyTotals: new Map(), // month 1-12 -> {minor,moderate,major,countYears}

  /* Top10 */
  top10: [] // [{rank, ft_mllw, stage, dt}]
};

/* === Chart plugin: horizontal threshold lines + labels === */
const thresholdPlugin = {
  id: "thresholdPlugin",
  afterDraw(chart, args, pluginOptions){
    const { ctx, chartArea, scales } = chart;
    if(!chartArea || !scales?.y) return;

    const y = scales.y;

    const lines = [
      { key:"minor", label:"Minor", color:getComputedStyle(document.documentElement).getPropertyValue("--minor").trim() || "#fbbf24" },
      { key:"moderate", label:"Moderate", color:getComputedStyle(document.documentElement).getPropertyValue("--moderate").trim() || "#fb7185" },
      { key:"major", label:"Major", color:getComputedStyle(document.documentElement).getPropertyValue("--major").trim() || "#a78bfa" },
    ];

    ctx.save();
    ctx.lineWidth = 1.25;
    ctx.setLineDash([6, 6]);
    ctx.font = "900 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textBaseline = "middle";

    for(const L of lines){
      const ft_disp = thresholdDisplay(L.key);
      if(!isFiniteNumber(ft_disp)) continue;
      const py = y.getPixelForValue(ft_disp);
      if(py < chartArea.top || py > chartArea.bottom) continue;

      ctx.strokeStyle = L.color;
      ctx.globalAlpha = 0.92;

      ctx.beginPath();
      ctx.moveTo(chartArea.left, py);
      ctx.lineTo(chartArea.right, py);
      ctx.stroke();

      // label near right edge
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.95;
      const txt = `${L.label} (${fmtFt(ft_disp)})`;
      const pad = 8;
      const tw = ctx.measureText(txt).width;
      const bx = chartArea.right - tw - pad*2 - 6;
      const by = py - 12;

      // rounded label background
      ctx.fillStyle = "rgba(0,0,0,.45)";
      roundRect(ctx, bx, by, tw + pad*2, 24, 10);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = 1;
      roundRect(ctx, bx, by, tw + pad*2, 24, 10);
      ctx.stroke();

      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.fillText(txt, bx + pad, py);

      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 1.25;
    }

    ctx.restore();
  }
};

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

/* === Button wiring === */
el.btnDatum.addEventListener("click", () => {
  DISPLAY_DATUM = (DISPLAY_DATUM === "MLLW") ? "NAVD88" : "MLLW";
  el.btnDatumText.textContent = `Datum: ${DISPLAY_DATUM === "MLLW" ? "MLLW" : "NAVD88"}`;

  // Re-render UI + charts using already-fetched internal MLLW series
  renderAll();
});

el.btnRefresh.addEventListener("click", () => refreshAll(true));

el.btnQuery.addEventListener("click", () => {
  // Implemented in Part 2 (hybrid lookup)
  window.__runQuery && window.__runQuery();
});
el.btnQueryClear.addEventListener("click", () => {
  el.queryDate.value = "";
  el.queryTime.value = "";
  el.queryResultRow.style.display = "none";
});

/* === Chart initialization skeletons (data filled in Part 2) === */
function initCharts(){
  Chart.register(thresholdPlugin);

  // Hydrograph
  const ctxH = document.getElementById("chartHydro");
  chartHydro = new Chart(ctxH, {
    type: "line",
    data: {
      datasets: [
        {
          label: "Observed (USGS)",
          data: [],
          parsing: false,
          borderWidth: 2.25,
          pointRadius: 0,
          tension: 0.25
        },
        {
          label: "Predicted (NWPS)",
          data: [],
          parsing: false,
          borderWidth: 2.25,
          pointRadius: 0,
          tension: 0.25
        }
      ]
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      interaction:{mode:"index", intersect:false},
      plugins:{
        legend:{
          labels:{ color:"rgba(234,240,255,.78)", font:{weight:"700"} }
        },
        tooltip:{
          callbacks:{
            label: (ctx) => {
              const v = ctx.parsed.y;
              return `${ctx.dataset.label}: ${fmtFt(v)} (${DISPLAY_DATUM})`;
            }
          }
        }
      },
      scales:{
        x:{
          type:"time",
          adapters:{date:{zone: TZ}},
          time:{ tooltipFormat:"LLL dd, yyyy • h:mm a", displayFormats:{hour:"LLL d ha"} },
          ticks:{ color:"rgba(169,182,211,.85)", maxRotation:0, autoSkip:true },
          grid:{ color:"rgba(255,255,255,.06)" }
        },
        y:{
          ticks:{
            color:"rgba(169,182,211,.85)",
            callback: (v)=> `${Number(v).toFixed(1)}`
          },
          grid:{ color:"rgba(255,255,255,.06)" }
        }
      }
    }
  });

  // Annual stacked bars
  const ctxA = document.getElementById("chartAnnual");
  chartAnnual = new Chart(ctxA, {
    type: "bar",
    data: {
      labels: [],
      datasets: [
        { label:"Minor", data: [], stack:"f", borderWidth:0 },
        { label:"Moderate", data: [], stack:"f", borderWidth:0 },
        { label:"Major", data: [], stack:"f", borderWidth:0 },
      ]
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{ labels:{ color:"rgba(234,240,255,.78)", font:{weight:"800"} } },
        tooltip:{ callbacks:{ label:(ctx)=> `${ctx.dataset.label}: ${ctx.parsed.y}` } }
      },
      scales:{
        x:{ ticks:{ color:"rgba(169,182,211,.85)" }, grid:{ color:"rgba(255,255,255,.06)" } },
        y:{ ticks:{ color:"rgba(169,182,211,.85)" }, grid:{ color:"rgba(255,255,255,.06)" }, beginAtZero:true }
      }
    }
  });

  // Monthly averages stacked bars
  const ctxM = document.getElementById("chartMonthly");
  chartMonthly = new Chart(ctxM, {
    type: "bar",
    data: {
      labels: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
      datasets: [
        { label:"Minor", data: new Array(12).fill(0), stack:"m", borderWidth:0 },
        { label:"Moderate", data: new Array(12).fill(0), stack:"m", borderWidth:0 },
        { label:"Major", data: new Array(12).fill(0), stack:"m", borderWidth:0 },
      ]
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{ labels:{ color:"rgba(234,240,255,.78)", font:{weight:"800"} } },
        tooltip:{ callbacks:{ label:(ctx)=> `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}` } }
      },
      scales:{
        x:{ ticks:{ color:"rgba(169,182,211,.85)" }, grid:{ color:"rgba(255,255,255,.06)" } },
        y:{ ticks:{ color:"rgba(169,182,211,.85)" }, grid:{ color:"rgba(255,255,255,.06)" }, beginAtZero:true }
      }
    }
  });

  // Note: dataset colors are applied in Part 2 after we read CSS variables (so it matches theme exactly).
}

/* === Render functions (data binding is in Part 2) === */
function renderAll(){
  renderHeader();
  renderKPIs();
  renderTop10();
  renderCharts();
}

function renderHeader(){
  if(STATE.lastUpdate){
    el.pageUpdated.textContent = fmtEst(STATE.lastUpdate);
  }else{
    el.pageUpdated.textContent = "—";
  }
  el.btnDatumText.textContent = `Datum: ${DISPLAY_DATUM === "MLLW" ? "MLLW" : "NAVD88"}`;
}

function renderKPIs(){
  // Filled in Part 2 once we have obs data for "now" and today min/max.
}

function renderTop10(){
  // Filled in Part 2.
}

function renderCharts(){
  // Filled in Part 2 (bind data, set y-limits, apply colors).
}

/* === Refresh orchestration (implemented in Part 2) === */
async function refreshAll(force){
  // Implemented in Part 2.
}

/* Boot */
initCharts();
renderAll();
refreshAll(false);
setInterval(()=> refreshAll(false), AUTO_REFRESH_MS);

/* =========================
PART 2 / 2 — PASTE THIS IMMEDIATELY AFTER PART 1
(continues inside the SAME <script> tag)
========================= */

/* =========================
USER: Top-10 seed list
Paste your historic top-ten list here (MLLW feet).
Format:
{ date:"YYYY-MM-DD", ft: 9.87 }  // ft in MLLW
========================= */
const TOP10_SEED_MLLW = [
  // TODO: paste your list here
];

/* =========================
Archive file datum
If your bivalve_daily_stats.txt is NAVD88, set to "NAVD88".
If it’s already MLLW, leave as "MLLW".
========================= */
const ARCHIVE_DATUM = "MLLW"; // "MLLW" | "NAVD88"

/* =========================
USGS JSON endpoints
========================= */
function usgsIvUrl({start, end, period}){
  const base = "https://waterservices.usgs.gov/nwis/iv/";
  const params = new URLSearchParams({
    format: "json",
    sites: USGS_SITE,
    parameterCd: USGS_PARAM_NAVD,
    siteStatus: "all"
  });
  if(period){
    params.set("period", period); // e.g. P2D
  }else{
    params.set("startDT", start.toISO({ suppressMilliseconds:true }));
    params.set("endDT", end.toISO({ suppressMilliseconds:true }));
  }
  return `${base}?${params.toString()}`;
}

/* =========================
NWPS API endpoint (official)
========================= */
const NWPS_GAUGE_URL = `https://api.water.noaa.gov/nwps/v1/gauges/${encodeURIComponent(NWPS_LID)}`; /* :contentReference[oaicite:0]{index=0} */

/* =========================
Colors (read from CSS vars so theme matches exactly)
========================= */
function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}
function applyDatasetColors(){
  const obsColor = cssVar("--ok") || "#2dd4bf";
  const fcstColor = cssVar("--accent") || "#7aa7ff";

  chartHydro.data.datasets[0].borderColor = obsColor;
  chartHydro.data.datasets[0].backgroundColor = obsColor;

  chartHydro.data.datasets[1].borderColor = fcstColor;
  chartHydro.data.datasets[1].backgroundColor = fcstColor;

  const minor = cssVar("--minor") || "#fbbf24";
  const moderate = cssVar("--moderate") || "#fb7185";
  const major = cssVar("--major") || "#a78bfa";

  for(const ch of [chartAnnual, chartMonthly]){
    ch.data.datasets[0].backgroundColor = minor;
    ch.data.datasets[1].backgroundColor = moderate;
    ch.data.datasets[2].backgroundColor = major;
  }
  chartHydro.update("none");
  chartAnnual.update("none");
  chartMonthly.update("none");
}

/* =========================
Parsing: archive txt (robust)
Goal: produce per-day up to TWO high tides.
We try to extract:
- a date (YYYY-MM-DD or MM/DD/YYYY)
- any floats on the line (we keep the 2 largest as “high tides”)
========================= */
function parseDateToken(tok){
  // YYYY-MM-DD
  if(/^\d{4}-\d{2}-\d{2}$/.test(tok)){
    const dt = DateTime.fromISO(tok, { zone: TZ });
    return dt.isValid ? dt : null;
  }
  // MM/DD/YYYY or M/D/YYYY
  if(/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(tok)){
    const dt = DateTime.fromFormat(tok, "M/d/yyyy", { zone: TZ });
    return dt.isValid ? dt : null;
  }
  return null;
}

function extractFloats(line){
  // floats including negative
  const matches = line.match(/-?\d+(?:\.\d+)?/g);
  if(!matches) return [];
  return matches.map(Number).filter(Number.isFinite);
}

function normalizeArchiveFtToMllw(ft){
  if(!isFiniteNumber(ft)) return null;
  if(ARCHIVE_DATUM === "MLLW") return ft;
  // archive is NAVD -> convert to MLLW
  return navdToMllw(ft);
}

function parseArchiveText(txt){
  const out = [];
  const lines = txt.split(/\r?\n/);

  for(const raw of lines){
    const line = raw.trim();
    if(!line) continue;
    if(line.startsWith("#")) continue;

    // find date token in the line
    const tokens = line.split(/[,\t ]+/).filter(Boolean);
    let dt = null;
    for(const tok of tokens){
      const maybe = parseDateToken(tok);
      if(maybe){ dt = maybe; break; }
    }
    if(!dt) continue;

    // extract floats; remove the date components if they got captured as numbers
    const nums = extractFloats(line);

    // Heuristic: keep only “plausible tide elevations” (0–25 ft)
    const plausible = nums.filter(v => v >= -5 && v <= 25);

    // If the file includes year/month/day numbers, plausible may include them; remove obvious year tokens
    const cleaned = plausible.filter(v => v < 1900 || v > 2100 ? true : false);

    // If removing years removed too much, fall back
    const vals = (cleaned.length >= 1 ? cleaned : plausible);

    if(vals.length === 0) continue;

    // take the 2 largest as “high tides”
    const highs = [...vals].sort((a,b)=>b-a).slice(0,2).map(normalizeArchiveFtToMllw).filter(isFiniteNumber);

    if(highs.length === 0) continue;

    out.push({
      date: dt.startOf("day"),
      highs_mllw: highs.sort((a,b)=>b-a)
    });
  }

  // de-duplicate by date (keep max two highs overall)
  const by = new Map();
  for(const r of out){
    const k = r.date.toISODate();
    const prev = by.get(k);
    if(!prev){
      by.set(k, r);
    }else{
      const merged = [...prev.highs_mllw, ...r.highs_mllw].sort((a,b)=>b-a).slice(0,2);
      by.set(k, { date: r.date, highs_mllw: merged });
    }
  }

  const final = [...by.values()].sort((a,b)=>a.date.toMillis()-b.date.toMillis());
  return final;
}

/* =========================
Compute flood counts from per-day highs
Classify each “event” by highest category only (minor OR moderate OR major)
Up to 2 events per day.
========================= */
function classifyEvent(ft_mllw){
  const st = stageFromMllw(ft_mllw);
  if(st === "major") return "major";
  if(st === "moderate") return "moderate";
  if(st === "minor") return "minor";
  return "none";
}

function addCounts(obj, cat, n){
  if(cat === "minor") obj.minor += n;
  else if(cat === "moderate") obj.moderate += n;
  else if(cat === "major") obj.major += n;
}

function buildCountsFromDaily(dailyArr){
  const annual = new Map();     // year -> {minor,moderate,major}
  const monthAgg = new Map();   // month -> {minor,moderate,major, years:Set}

  for(let m=1;m<=12;m++){
    monthAgg.set(m, { minor:0, moderate:0, major:0, years:new Set() });
  }

  for(const d of dailyArr){
    const year = d.date.year;
    const month = d.date.month;

    if(!annual.has(year)) annual.set(year, { minor:0, moderate:0, major:0 });
    const a = annual.get(year);

    const mObj = monthAgg.get(month);
    mObj.years.add(year);

    // up to 2 highs
    for(const ft of d.highs_mllw.slice(0,2)){
      const cat = classifyEvent(ft);
      if(cat === "none") continue;
      addCounts(a, cat, 1);
      addCounts(mObj, cat, 1);
    }
  }

  // convert monthAgg -> monthly averages (divide by #years represented for that month)
  const monthlyAvg = new Map();
  for(const [m, v] of monthAgg.entries()){
    const denom = Math.max(1, v.years.size);
    monthlyAvg.set(m, { minor: v.minor/denom, moderate: v.moderate/denom, major: v.major/denom, yearsCount: v.years.size });
  }

  return { annual, monthlyAvg };
}

/* =========================
USGS observations (24h)
USGS returns NAVD88 feet; convert to MLLW internally.
========================= */
async function fetchUsgsObs24h(){
  const end = nowEst();
  const start = end.minus({ hours: 30 }); // buffer
  const url = usgsIvUrl({ start, end });

  const res = await fetch(url, { cache: "no-store" });
  if(!res.ok) throw new Error(`USGS fetch failed (${res.status})`);
  const js = await res.json();

  const ts = js?.value?.timeSeries?.[0];
  const vals = ts?.values?.[0]?.value || [];
  const out = [];

  for(const row of vals){
    const t = DateTime.fromISO(row.dateTime, { zone: "utc" }).setZone(TZ);
    const ft_navd = Number(row.value);
    if(!t.isValid || !Number.isFinite(ft_navd)) continue;

    out.push({ t, ft_mllw: navdToMllw(ft_navd) });
  }

  // keep last 24h
  const cutoff = end.minus({ hours: 24 });
  return out.filter(p => p.t >= cutoff).sort((a,b)=>a.t.toMillis()-b.t.toMillis());
}

/* =========================
NWPS gauge parsing (72h forecast)
We fetch the gauge JSON and then try to extract a forecast series.
NWPS API overview: :contentReference[oaicite:1]{index=1}
========================= */
function deepFindTimeSeries(obj){
  // Return candidate arrays that look like time series.
  const candidates = [];
  const seen = new Set();

  function walk(x){
    if(!x || typeof x !== "object") return;
    if(seen.has(x)) return;
    seen.add(x);

    if(Array.isArray(x)){
      // array of objects with time+value?
      if(x.length >= 2 && typeof x[0] === "object" && x[0]){
        const keys = Object.keys(x[0]);
        const hasTime = keys.some(k => /time|date/i.test(k));
        const hasValue = keys.some(k => /value|stage|flow|primary/i.test(k));
        if(hasTime && hasValue) candidates.push(x);
      }
      for(const it of x) walk(it);
      return;
    }

    for(const k of Object.keys(x)){
      walk(x[k]);
    }
  }

  walk(obj);
  return candidates;
}

function normalizeNwpsPoint(p){
  if(!p || typeof p !== "object") return null;

  // Common key patterns
  const timeKey = Object.keys(p).find(k => /validTime|time|date/i.test(k));
  const valKey = Object.keys(p).find(k => /primary|value|stage|observed|forecast/i.test(k));

  const rawT = timeKey ? p[timeKey] : null;
  const rawV = valKey ? p[valKey] : null;

  let t = null;
  if(typeof rawT === "string"){
    // sometimes "2026-01-20T12:00:00Z" or "2026-01-20 12:00"
    t = DateTime.fromISO(rawT, { zone: "utc" });
    if(!t.isValid){
      t = DateTime.fromFormat(rawT, "yyyy-LL-dd HH:mm", { zone: TZ });
    }
  }else if(rawT && typeof rawT === "object" && rawT.dateTime){
    t = DateTime.fromISO(rawT.dateTime, { zone: "utc" });
  }

  let v = null;
  if(typeof rawV === "number") v = rawV;
  else if(typeof rawV === "string") v = Number(rawV);
  else if(rawV && typeof rawV === "object"){
    // sometimes {value: "..."} or {primary: "..."}
    const vk = Object.keys(rawV).find(k => /value|primary|stage/i.test(k));
    if(vk) v = Number(rawV[vk]);
  }

  if(!t || !t.isValid || !Number.isFinite(v)) return null;

  // NWPS stage is typically in feet at the gauge datum (commonly NAVD88 for these products).
  // We treat it as NAVD88 and convert to MLLW internally to keep everything consistent.
  const ft_mllw = navdToMllw(v);

  return { t: t.setZone(TZ), ft_mllw };
}

async function fetchNwpsForecast72h(){
  const res = await fetch(NWPS_GAUGE_URL, { cache: "no-store" });
  if(!res.ok) throw new Error(`NWPS fetch failed (${res.status})`);
  const js = await res.json();

  // Try to locate forecast series explicitly by searching keys
  // Otherwise, deep-scan for series-looking arrays and take the one with the latest end-time.
  const candidates = deepFindTimeSeries(js);

  let best = [];
  let bestScore = -Infinity;

  for(const arr of candidates){
    const pts = arr.map(normalizeNwpsPoint).filter(Boolean);
    if(pts.length < 10) continue;

    pts.sort((a,b)=>a.t.toMillis()-b.t.toMillis());
    const spanH = (pts[pts.length-1].t.toMillis() - pts[0].t.toMillis()) / 3.6e6;

    // prefer longer span and points mostly in the future
    const now = nowEst();
    const futureFrac = pts.filter(p => p.t >= now.minus({ hours: 2 })).length / pts.length;
    const score = spanH + 50*futureFrac;

    if(score > bestScore){
      bestScore = score;
      best = pts;
    }
  }

  const now = nowEst();
  const end = now.plus({ hours: 72 });

  return best
    .filter(p => p.t >= now.minus({ hours: 1 }) && p.t <= end)
    .sort((a,b)=>a.t.toMillis()-b.t.toMillis());
}

/* =========================
Daily range (today) from obs points
========================= */
function computeTodayRangeFromObs(obs){
  const today = nowEst().startOf("day");
  const tomorrow = today.plus({ days: 1 });

  const pts = obs.filter(p => p.t >= today && p.t < tomorrow).map(p => p.ft_mllw);
  if(pts.length === 0) return null;

  const min = Math.min(...pts);
  const max = Math.max(...pts);
  return { min_mllw: min, max_mllw: max };
}

/* =========================
Top-10 logic
We store internally in MLLW.
We can update by checking recent obs maxima.
========================= */
function seedTop10(){
  const rows = [];
  for(const r of TOP10_SEED_MLLW){
    const dt = DateTime.fromISO(r.date, { zone: TZ });
    const ft = Number(r.ft);
    if(!dt.isValid || !Number.isFinite(ft)) continue;
    rows.push({
      dt: dt.startOf("day"),
      ft_mllw: ft,
      stage: stageFromMllw(ft)
    });
  }
  rows.sort((a,b)=>b.ft_mllw-a.ft_mllw);
  STATE.top10 = rows.slice(0,10);
}

function maybeInsertTop10(candidate){
  // candidate: {dt, ft_mllw}
  if(!candidate || !isFiniteNumber(candidate.ft_mllw) || !candidate.dt?.isValid) return;

  const existing = STATE.top10.find(x => x.dt.toISODate() === candidate.dt.toISODate());
  if(existing){
    if(candidate.ft_mllw <= existing.ft_mllw) return;
    existing.ft_mllw = candidate.ft_mllw;
    existing.stage = stageFromMllw(candidate.ft_mllw);
  }else{
    STATE.top10.push({ dt: candidate.dt, ft_mllw: candidate.ft_mllw, stage: stageFromMllw(candidate.ft_mllw) });
  }

  STATE.top10.sort((a,b)=>b.ft_mllw-a.ft_mllw);
  STATE.top10 = STATE.top10.slice(0,10);
}

async function updateTop10FromRecentUSGS(){
  // Look back 30 days; if a new daily maximum exceeds 10th place, insert
  const end = nowEst();
  const start = end.minus({ days: 30 });

  const url = usgsIvUrl({ start, end });
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) return;

  const js = await res.json();
  const vals = js?.value?.timeSeries?.[0]?.values?.[0]?.value || [];
  const points = [];

  for(const row of vals){
    const t = DateTime.fromISO(row.dateTime, { zone:"utc" }).setZone(TZ);
    const ft_navd = Number(row.value);
    if(!t.isValid || !Number.isFinite(ft_navd)) continue;
    points.push({ t, ft_mllw: navdToMllw(ft_navd) });
  }
  if(points.length === 0) return;

  // group by day and take max
  const byDay = new Map();
  for(const p of points){
    const k = p.t.startOf("day").toISODate();
    const prev = byDay.get(k);
    if(!prev || p.ft_mllw > prev.ft_mllw){
      byDay.set(k, { dt: p.t.startOf("day"), ft_mllw: p.ft_mllw });
    }
  }

  const tenth = STATE.top10.length >= 10 ? STATE.top10[STATE.top10.length-1].ft_mllw : -Infinity;

  for(const v of byDay.values()){
    if(v.ft_mllw > tenth){
      maybeInsertTop10(v);
    }
  }
}

/* =========================
Post-2025 flood counts (2026+)
Compute up to 2 floods/day using local maxima detection.
We do: find peaks above minor threshold, then keep up to 2 per day.
========================= */
function detectDailyPeaks(points){
  // points: [{t, ft_mllw}] sorted
  // return Map dayISO -> [peak1, peak2] (values)
  const byDay = new Map();

  function pushPeak(dayKey, ft){
    if(!byDay.has(dayKey)) byDay.set(dayKey, []);
    const arr = byDay.get(dayKey);
    arr.push(ft);
  }

  for(let i=1; i<points.length-1; i++){
    const a = points[i-1], b = points[i], c = points[i+1];
    if(!a || !b || !c) continue;

    // simple peak: b higher than neighbors
    if(b.ft_mllw >= a.ft_mllw && b.ft_mllw >= c.ft_mllw){
      if(b.ft_mllw < THRESH_MLLW.minor) continue;
      const dayKey = b.t.startOf("day").toISODate();
      pushPeak(dayKey, b.ft_mllw);
    }
  }

  // keep top 2 per day
  for(const [k, arr] of byDay.entries()){
    const top2 = arr.sort((x,y)=>y-x).slice(0,2);
    byDay.set(k, top2);
  }
  return byDay;
}

async function fetchUsgsRangePoints(start, end){
  const url = usgsIvUrl({ start, end });
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error(`USGS range fetch failed (${res.status})`);
  const js = await res.json();

  const vals = js?.value?.timeSeries?.[0]?.values?.[0]?.value || [];
  const pts = [];
  for(const row of vals){
    const t = DateTime.fromISO(row.dateTime, { zone:"utc" }).setZone(TZ);
    const ft_navd = Number(row.value);
    if(!t.isValid || !Number.isFinite(ft_navd)) continue;
    pts.push({ t, ft_mllw: navdToMllw(ft_navd) });
  }
  pts.sort((a,b)=>a.t.toMillis()-b.t.toMillis());
  return pts;
}

async function computeLiveDailyFloodsSince2026(){
  // Only compute from Jan 1, 2026 through now (and chunk to avoid huge USGS pulls)
  const startAll = DateTime.fromObject({ year: 2026, month: 1, day: 1, zone: TZ });
  const endAll = nowEst();

  // chunk in ~30-day pieces
  let cursor = startAll;
  const daily = new Map(); // dayISO -> [peak1,peak2]

  while(cursor < endAll){
    const chunkEnd = DateTime.min(cursor.plus({ days: 30 }), endAll);
    const pts = await fetchUsgsRangePoints(cursor, chunkEnd.plus({ hours: 1 })); // buffer
    const peaks = detectDailyPeaks(pts);

    for(const [k, arr] of peaks.entries()){
      // merge
      const prev = daily.get(k) || [];
      const merged = [...prev, ...arr].sort((a,b)=>b-a).slice(0,2);
      daily.set(k, merged);
    }

    cursor = chunkEnd;
  }

  // convert to daily array objects like archive
  const out = [];
  for(const [k, highs] of daily.entries()){
    const dt = DateTime.fromISO(k, { zone: TZ }).startOf("day");
    out.push({ date: dt, highs_mllw: highs.sort((a,b)=>b-a) });
  }
  out.sort((a,b)=>a.date.toMillis()-b.date.toMillis());
  return out;
}

/* =========================
Historic tide query tool (hybrid)
- If date <= 2025-12-31 => archive daily max (time ignored, archive is daily)
- Else => fetch USGS that day and find nearest (or daily max if no time)
========================= */
function setQueryResult({ft_mllw, dt, source}){
  const ft_disp = toDisplayFromMllw(ft_mllw);
  const stage = stageFromMllw(ft_mllw);

  el.queryResultValue.textContent = `${fmtFt(ft_disp)} (${DISPLAY_DATUM})`;
  el.queryResultStage.textContent = stageLabel(stage);
  el.queryResultSource.textContent = source;
  el.queryResultTs.textContent = dt ? fmtEst(dt) : "—";
  el.queryResultRow.style.display = "flex";
}

async function runQuery(){
  const d = (el.queryDate.value || "").trim();
  const t = (el.queryTime.value || "").trim();

  const dtDay = DateTime.fromISO(d, { zone: TZ });
  if(!dtDay.isValid){
    el.queryResultRow.style.display = "none";
    return;
  }

  const cutoff = DateTime.fromISO("2025-12-31", { zone: TZ }).endOf("day");

  // archive path
  if(dtDay <= cutoff){
    const key = dtDay.startOf("day").toISODate();
    const rec = STATE.archiveDaily.find(x => x.date.toISODate() === key);
    if(!rec){
      el.queryResultRow.style.display = "none";
      return;
    }
    const maxFt = rec.highs_mllw[0];
    setQueryResult({
      ft_mllw: maxFt,
      dt: rec.date,
      source: t ? "Archive (daily max; archive is daily so time is ignored)" : "Archive (daily max)"
    });
    return;
  }

  // live USGS path
  const dayStart = dtDay.startOf("day");
  const dayEnd = dayStart.plus({ days: 1 });

  const pts = await fetchUsgsRangePoints(dayStart, dayEnd);
  if(pts.length === 0){
    el.queryResultRow.style.display = "none";
    return;
  }

  if(t){
    const dtTarget = DateTime.fromFormat(`${d} ${t}`, "yyyy-LL-dd HH:mm", { zone: TZ });
    if(dtTarget.isValid){
      let best = pts[0];
      let bestDist = Math.abs(pts[0].t.toMillis() - dtTarget.toMillis());
      for(const p of pts){
        const dist = Math.abs(p.t.toMillis() - dtTarget.toMillis());
        if(dist < bestDist){
          bestDist = dist;
          best = p;
        }
      }
      setQueryResult({ ft_mllw: best.ft_mllw, dt: best.t, source: "USGS (nearest observed point)" });
      return;
    }
  }

  // else daily max
  let maxP = pts[0];
  for(const p of pts){
    if(p.ft_mllw > maxP.ft_mllw) maxP = p;
  }
  setQueryResult({ ft_mllw: maxP.ft_mllw, dt: maxP.t, source: "USGS (daily max)" });
}
window.__runQuery = runQuery;

/* =========================
Renderers
========================= */
function renderKPIs(){
  // Current elevation: last observed point (or last forecast if obs empty)
  let latest = null;
  if(STATE.obs.length) latest = STATE.obs[STATE.obs.length-1];
  else if(STATE.fcst.length) latest = STATE.fcst[0];

  if(latest){
    const ft_disp = toDisplayFromMllw(latest.ft_mllw);
    const st = stageFromMllw(latest.ft_mllw);

    el.kpiNow.textContent = fmtFt(ft_disp);
    el.kpiNowUpdated.textContent = fmtEst(latest.t);

    el.kpiStageBadge.className = `badge ${stageBadgeClass(st)}`;
    el.kpiStageBadge.textContent = stageLabel(st);

    el.btnStageText.textContent = `Stage: ${stageLabel(st)}`;
    const dotClass = stageDotClass(st);
    el.dotFresh.className = `dot ${dotClass}`.trim();
  }else{
    el.kpiNow.textContent = "—";
    el.kpiNowUpdated.textContent = "—";
    el.kpiStageBadge.className = "badge";
    el.kpiStageBadge.textContent = "—";
    el.btnStageText.textContent = "Stage: —";
    el.dotFresh.className = "dot";
  }

  // Daily range: from obs (today)
  const range = computeTodayRangeFromObs(STATE.obs);
  if(range){
    const minD = toDisplayFromMllw(range.min_mllw);
    const maxD = toDisplayFromMllw(range.max_mllw);
    el.kpiRange.textContent = `${fmtFt(minD)} – ${fmtFt(maxD)}`;
    el.kpiRangeUpdated.textContent = latest ? fmtEst(latest.t) : "—";
  }else{
    el.kpiRange.textContent = "—";
    el.kpiRangeUpdated.textContent = "—";
  }
}

function renderTop10(){
  const body = el.top10Body;
  body.innerHTML = "";

  if(!STATE.top10.length){
    body.innerHTML = `<tr><td colspan="4" class="muted">Paste your TOP10_SEED_MLLW list in Part 2 to seed this table.</td></tr>`;
    return;
  }

  STATE.top10.forEach((r, i) => {
    const ft_disp = toDisplayFromMllw(r.ft_mllw);
    const stage = stageFromMllw(r.ft_mllw);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="rank">${i+1}</td>
      <td><b>${fmtFt(ft_disp)}</b> <span class="muted">(${DISPLAY_DATUM})</span></td>
      <td>
        <span class="stageTag ${stage}">
          <span class="miniDot"></span>
          ${stageLabel(stage)}
        </span>
      </td>
      <td>${r.dt.setZone(TZ).toFormat("LLL dd, yyyy")}</td>
    `;
    body.appendChild(tr);
  });
}

function renderCharts(){
  // Hydrograph data
  const obsXY = STATE.obs.map(p => ({ x: p.t.toISO(), y: toDisplayFromMllw(p.ft_mllw) }));
  const fcstXY = STATE.fcst.map(p => ({ x: p.t.toISO(), y: toDisplayFromMllw(p.ft_mllw) }));

  chartHydro.data.datasets[0].data = obsXY;
  chartHydro.data.datasets[1].data = fcstXY;

  // y-range (fit obs+fcst+thresholds)
  const allY = [...obsXY, ...fcstXY].map(p => p.y).filter(isFiniteNumber);
  const thr = ["minor","moderate","major"].map(k => thresholdDisplay(k)).filter(isFiniteNumber);
  const ys = [...allY, ...thr];

  if(ys.length){
    const min = Math.min(...ys);
    const max = Math.max(...ys);
    const pad = Math.max(0.4, (max-min)*0.12);
    chartHydro.options.scales.y.min = Math.floor((min - pad) * 10)/10;
    chartHydro.options.scales.y.max = Math.ceil((max + pad) * 10)/10;
  }

  chartHydro.update("none");

  // Annual stacked counts
  const years = [...STATE.annualCounts.keys()].sort((a,b)=>a-b);
  chartAnnual.data.labels = years.map(String);
  chartAnnual.data.datasets[0].data = years.map(y => STATE.annualCounts.get(y).minor || 0);
  chartAnnual.data.datasets[1].data = years.map(y => STATE.annualCounts.get(y).moderate || 0);
  chartAnnual.data.datasets[2].data = years.map(y => STATE.annualCounts.get(y).major || 0);
  chartAnnual.update("none");

  // Monthly averages
  const mVals = [];
  for(let m=1;m<=12;m++){
    const v = STATE.monthlyTotals.get(m) || { minor:0, moderate:0, major:0 };
    mVals.push(v);
  }
  chartMonthly.data.datasets[0].data = mVals.map(v => v.minor);
  chartMonthly.data.datasets[1].data = mVals.map(v => v.moderate);
  chartMonthly.data.datasets[2].data = mVals.map(v => v.major);
  chartMonthly.update("none");
}

/* =========================
Hybrid build: archive + live
========================= */
function mergeDailyArrays(a, b){
  // both arrays of {date, highs_mllw}; b overrides/extends a for newer dates
  const by = new Map();
  for(const r of a){
    by.set(r.date.toISODate(), { date:r.date, highs_mllw:r.highs_mllw.slice(0,2) });
  }
  for(const r of b){
    by.set(r.date.toISODate(), { date:r.date, highs_mllw:r.highs_mllw.slice(0,2) });
  }
  return [...by.values()].sort((x,y)=>x.date.toMillis()-y.date.toMillis());
}

/* =========================
Archive loader
========================= */
async function loadArchive(){
  const res = await fetch(ARCHIVE_TXT_PATH, { cache:"no-store" });
  if(!res.ok) throw new Error(`Could not fetch ${ARCHIVE_TXT_PATH} (${res.status}). Put it in repo root.`);
  const txt = await res.text();

  const daily = parseArchiveText(txt);
  // Keep only 2000–2025 for the historic chart
  const daily2000_2025 = daily.filter(r => r.date.year >= 2000 && r.date.year <= 2025);

  STATE.archiveDaily = daily2000_2025;
}

/* =========================
Refresh pipeline
========================= */
async function refreshAll(force){
  const started = nowEst();
  try{
    // 1) Ensure colors applied once
    applyDatasetColors();

    // 2) Load archive once (or force)
    if(force || !STATE.archiveDaily.length){
      await loadArchive();
    }

    // 3) Fetch live obs (24h) + forecast (72h)
    const [obs, fcst] = await Promise.all([
      fetchUsgsObs24h(),
      fetchNwpsForecast72h()
    ]);
    STATE.obs = obs;
    STATE.fcst = fcst;

    // 4) Seed top10 once
    if(!STATE.top10.length){
      seedTop10();
    }

    // 5) Update top10 from recent USGS maxima
    await updateTop10FromRecentUSGS();

    // 6) Compute post-2025 daily floods (2026+), then build combined counts
    const liveDaily = await computeLiveDailyFloodsSince2026();
    const combinedDaily = mergeDailyArrays(STATE.archiveDaily, liveDaily);

    const { annual, monthlyAvg } = buildCountsFromDaily(combinedDaily);

    // Keep annual counts through current year
    STATE.annualCounts = annual;

    // Monthly averages
    const monthlyMap = new Map();
    for(let m=1;m<=12;m++){
      const v = monthlyAvg.get(m) || { minor:0, moderate:0, major:0 };
      monthlyMap.set(m, { minor:v.minor, moderate:v.moderate, major:v.major });
    }
    STATE.monthlyTotals = monthlyMap;

    // 7) Update UI
    STATE.lastUpdate = started;
    renderAll();
  }catch(err){
    console.error(err);
    // still show update time + keep prior data
    STATE.lastUpdate = started;
    renderHeader();
  }
}

/* Finalize: override the stub renderers from Part 1 with filled versions */
window.renderAll = renderAll;
window.renderHeader = renderHeader;
window.renderKPIs = renderKPIs;
window.renderTop10 = renderTop10;
window.renderCharts = renderCharts;
window.refreshAll = refreshAll;

/* One more paint */
renderAll();

/* Close script + page */
  </script>
</body>
</html>
