/* ===========================
   PART 1/4 — TXT daily tides loader (NAVD88)
   Source file: data/daily_tides_navd88.txt

   Columns in your file:
   - 239251_72279_00021 = Tidal High (Daily)
   - 239252_72279_00022 = Tidal Low-High (Daily)
   =========================== */

const DAILY_TIDES_TXT_URL = "data/daily_tides_navd88.txt";

// Your file’s exact column names (tab-delimited USGS output)
const COL_DAILY_HIGH  = "239251_72279_00021"; // daily tidal high (NAVD88 ft)
const COL_DAILY_LOWHI = "239252_72279_00022"; // daily tidal low-high (NAVD88 ft)

// Parsed daily rows from TXT (NAVD88)
let DAILY_TIDES = []; 
// Each row: { y, m, d, dateISO, highNavd, lowhiNavd }

// Expanded “events” (two possible per day), used by:
// - Monthly averages
// - Historic tides filter
// - Annual bars (past completed years)
let DAILY_EVENTS_NAVD = [];
// Each row: { t, ft, kind: "High" | "Low-High", y, m, d }

/* Robust parser for USGS tab-delimited TXT:
   - skips comment lines that start with '#'
   - finds header line starting with "agency_cd\t"
   - skips the “format spec” line like: "5s 15s 20d ..."
*/
function parseUSGSDailyTidesTXT(text){
  const lines = text.split(/\r?\n/);

  // Find header line (starts with agency_cd)
  let headerLineIndex = -1;
  for(let i=0;i<lines.length;i++){
    const ln = lines[i];
    if(!ln) continue;
    if(ln.startsWith("#")) continue;
    if(ln.startsWith("agency_cd\t")) { headerLineIndex = i; break; }
  }
  if(headerLineIndex < 0) throw new Error("Could not find header row (agency_cd ...) in TXT.");

  const header = lines[headerLineIndex].split("\t");
  const idxDate = header.indexOf("datetime");
  const idxHigh = header.indexOf(COL_DAILY_HIGH);
  const idxLowHi = header.indexOf(COL_DAILY_LOWHI);

  if(idxDate < 0) throw new Error("TXT missing 'datetime' column.");
  if(idxHigh < 0) throw new Error(`TXT missing ${COL_DAILY_HIGH} column.`);
  if(idxLowHi < 0) throw new Error(`TXT missing ${COL_DAILY_LOWHI} column.`);

  const out = [];

  for(let i=headerLineIndex+1;i<lines.length;i++){
    const ln = lines[i];
    if(!ln) continue;
    if(ln.startsWith("#")) continue;

    // Skip the USGS “field type” line (e.g., "5s\t15s\t20d\t14n...")
    if(/^\d+s\t/.test(ln) && ln.includes("20d")) continue;

    const parts = ln.split("\t");
    if(parts.length < header.length) continue;

    const dtStr = (parts[idxDate] || "").trim(); // YYYY-MM-DD
    if(!dtStr || !/^\d{4}-\d{2}-\d{2}$/.test(dtStr)) continue;

    const y = +dtStr.slice(0,4);
    const m = +dtStr.slice(5,7);
    const d = +dtStr.slice(8,10);

    // Keep as UTC midnight ISO for stable grouping keys
    const dateISO = dtStr + "T00:00:00Z";

    const highStr  = (parts[idxHigh] || "").trim();
    const lowhiStr = (parts[idxLowHi] || "").trim();

    const highNavd  = highStr  === "" ? null : +highStr;
    const lowhiNavd = lowhiStr === "" ? null : +lowhiStr;

    // Keep row if at least one exists
    if((highNavd !== null && Number.isFinite(highNavd)) || (lowhiNavd !== null && Number.isFinite(lowhiNavd))){
      out.push({
        y, m, d,
        dateISO,
        highNavd:  Number.isFinite(highNavd)  ? highNavd  : null,
        lowhiNavd: Number.isFinite(lowhiNavd) ? lowhiNavd : null
      });
    }
  }

  out.sort((a,b)=>new Date(a.dateISO)-new Date(b.dateISO));
  return out;
}

/* Expand daily rows into “events”:
   - Up to 2 events/day (High + Low-High)
   - We assign an arbitrary timestamp at 12:00 EST (17:00Z) so your existing
     formatter + table can display something consistent.
   NOTE: This does NOT change magnitudes; it’s just for display/sorting by time.
*/
function buildDailyEventsFromDailyTides(rows){
  const ev = [];
  for(const r of rows){
    const t = new Date(Date.UTC(r.y, r.m-1, r.d, 17, 0, 0)).toISOString(); // 12:00 EST
    if(r.highNavd !== null) ev.push({ t, ft: r.highNavd,  kind:"High",     y:r.y, m:r.m, d:r.d });
    if(r.lowhiNavd !== null) ev.push({ t, ft: r.lowhiNavd, kind:"Low-High", y:r.y, m:r.m, d:r.d });
  }
  ev.sort((a,b)=>new Date(a.t)-new Date(b.t));
  return ev;
}

async function loadDailyTidesFromTXT(){
  const res = await fetch(DAILY_TIDES_TXT_URL, { cache:"no-store" });
  if(!res.ok) throw new Error(`Daily tides TXT missing/unreadable (${res.status}).`);
  const text = await res.text();

  DAILY_TIDES = parseUSGSDailyTidesTXT(text);
  DAILY_EVENTS_NAVD = buildDailyEventsFromDailyTides(DAILY_TIDES);

  // Optional sanity log
  console.log("Loaded DAILY_TIDES rows:", DAILY_TIDES.length, "events:", DAILY_EVENTS_NAVD.length);
}
/* ===========================
   PART 2/4 — Rewire: TXT drives
   (A) Historic tides filter
   (B) Monthly averages
   (C) Annual flooding bars (completed years from TXT)
   + Wire TXT loader into boot()

   NOTE: Live JSON still drives:
   - current water level
   - last 24h observations (15-min)
   - YTD flood counts for CURRENT YEAR
   - NOAA predictions
   =========================== */

/* ---------- Helpers: date keys + grouping ---------- */
function monthKey(y,m){ return `${y}-${m}`; }
function yearKey(y){ return `${y}`; }

/* ---------- (A) Historic tides filter now uses TXT daily events ---------- */
/* Replace your current loadHistoric()/HIGH_TIDES_NAVD usage with this:

   - We keep HIGH_TIDES_NAVD as the backing array for the filter table
   - But populate it from DAILY_EVENTS_NAVD (TXT), not events.json
*/
function hydrateHistoricFromTXT(){
  // DAILY_EVENTS_NAVD items are already {t, ft, kind, y,m,d}
  // High tides table expects NAVD series with {t, ft}
  HIGH_TIDES_NAVD = DAILY_EVENTS_NAVD.map(e=>({ t:e.t, ft:e.ft, kind:e.kind, y:e.y, m:e.m, d:e.d }));

  // Default sort: most recent first (like before)
  HIGH_TIDES_NAVD.sort((a,b)=>new Date(b.t)-new Date(a.t));

  // Apply the UI filter/sort currently selected
  applyFilter();
  histMeta.textContent = HIGH_TIDES_NAVD.length
    ? `Loaded ${HIGH_TIDES_NAVD.length.toLocaleString()} daily events from TXT (High + Low-High).`
    : "TXT loaded, but no daily events found.";
}

/* OPTIONAL: show kind column in the Historic table without changing layout:
   Your table currently has Date/Time, Peak, Type. We'll keep Type as flood stage,
   and prepend kind to the Date cell to preserve layout.
   If you want NO kind label shown, comment out this override.
*/
const _renderHist_original = renderHist;
renderHist = function(rowsNavd){
  histBody.innerHTML="";
  const show=rowsNavd.slice(0, 100);
  for(const r of show){
    const t=stageTagByNavd(r.ft);
    const disp = toDisplayFtFromNavd(r.ft);
    const label = r.kind ? `${r.kind} · ` : "";
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${label}${fmtESTFull(r.t)}</td>
      <td><b>${disp.toFixed(2)}</b></td>
      <td><span class="tag"><span class="chip" style="background:${t.c}"></span>${t.txt}</span></td>
    `;
    histBody.appendChild(tr);
  }
  histMeta.textContent=`Showing ${Math.min(100, rowsNavd.length)} of ${rowsNavd.length.toLocaleString()}`;
};

/* ---------- (B) Monthly averages computed from TXT daily events ---------- */
/* Replace your existing updateMonthAveragesFromHistoric() so it uses DAILY_EVENTS_NAVD.
   IMPORTANT: We count up to TWO floods per day (High + Low-High) because the TXT
   explicitly gives both daily event types.
*/
function computeMonthlyAveragesFromEvents(peaksNavd){
  const T = THRESH.NAVD88;
  const byYearMonth = new Map(); // key y-m
  const yearsSet = new Set();

  for(const p of peaksNavd){
    // Use stored y,m if present; otherwise derive from ISO
    let y = p.y, m = p.m;
    if(!y || !m){
      const dt = new Date(p.t);
      if(Number.isNaN(dt.getTime())) continue;
      y = dt.getUTCFullYear();
      m = dt.getUTCMonth()+1;
    }
    yearsSet.add(y);
    const key = monthKey(y,m);
    if(!byYearMonth.has(key)){
      byYearMonth.set(key,{year:y, month:m, total:0, minor:0, moderate:0, major:0});
    }
    const rec = byYearMonth.get(key);

    if(p.ft >= T.minorLow){
      rec.total++;
      if(p.ft >= T.majorLow) rec.major++;
      else if(p.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }

  const years = Array.from(yearsSet).sort((a,b)=>a-b);
  const result = [];
  for(let m=1;m<=12;m++){
    const rowsForMonth=[];
    for(const y of years){
      const key = monthKey(y,m);
      if(byYearMonth.has(key)) rowsForMonth.push(byYearMonth.get(key));
      else rowsForMonth.push({year:y, month:m, total:0, minor:0, moderate:0, major:0});
    }
    const n = rowsForMonth.length || 1;
    const sum = rowsForMonth.reduce((acc,r)=>{
      acc.total += r.total;
      acc.minor += r.minor;
      acc.moderate += r.moderate;
      acc.major += r.major;
      return acc;
    },{total:0, minor:0, moderate:0, major:0});

    result.push({
      month:m,
      avgTotal: sum.total / n,
      avgMinor: sum.minor / n,
      avgModerate: sum.moderate / n,
      avgMajor: sum.major / n,
      years:n
    });
  }
  return result;
}

function updateMonthAveragesFromTXT(){
  if(!DAILY_EVENTS_NAVD || !DAILY_EVENTS_NAVD.length){
    monthAvgMeta.textContent="No TXT daily events loaded yet.";
    const zeros = Array.from({length:12},(_,i)=>({month:i+1,avgTotal:0,avgMinor:0,avgModerate:0,avgMajor:0,years:0}));
    renderMonthAveragesTable(zeros);
    renderMonthAveragesChart(zeros);
    return;
  }
  const stats = computeMonthlyAveragesFromEvents(HIGH_TIDES_NAVD); // already hydrated from TXT
  monthAvgMeta.textContent = `Averages across ${stats[0]?.years ?? 0} years (computed from TXT daily High + Low-High events).`;
  renderMonthAveragesTable(stats);
  renderMonthAveragesChart(stats);
}

/* ---------- (C) Annual flooding bars:
   - Completed years come from TXT daily events
   - Current year stays live (your existing updateLiveAndAnnualCounts()) and overwrites the current bar

   We replace base arrays usage with TXT-derived arrays for all years in the TXT.
*/
function countFloodEventsByYearFromTXT(eventsNavd){
  const T = THRESH.NAVD88;
  const byYear = new Map(); // y -> {minor, moderate, major}
  for(const e of eventsNavd){
    const y = e.y || (new Date(e.t)).getUTCFullYear();
    if(!byYear.has(y)) byYear.set(y,{minor:0, moderate:0, major:0});
    if(e.ft >= T.minorLow){
      const rec = byYear.get(y);
      if(e.ft >= T.majorLow) rec.major++;
      else if(e.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }
  return byYear;
}

/* Build annual arrays from TXT; then live YTD overwrites current year later */
function buildAnnualArraysFromTXT(){
  const {y:curYear}=getESTParts(new Date());

  if(!HIGH_TIDES_NAVD || !HIGH_TIDES_NAVD.length){
    // fallback to existing behavior if TXT not loaded
    buildAnnualArraysWithLiveCurrentYear(null);
    return;
  }

  const byYear = countFloodEventsByYearFromTXT(HIGH_TIDES_NAVD);

  const years = Array.from(byYear.keys()).sort((a,b)=>a-b);

  // Ensure we include current year even if TXT doesn't have it yet
  if(!years.includes(curYear)) years.push(curYear);

  YEARS = years;
  annualMinor = YEARS.map(y=> byYear.get(y)?.minor ?? 0);
  annualModerate = YEARS.map(y=> byYear.get(y)?.moderate ?? 0);
  annualMajor = YEARS.map(y=> byYear.get(y)?.major ?? 0);

  // NOTE: current year will be overwritten by live YTD in updateLiveAndAnnualCounts()
}

/* Override your existing buildAnnualArraysWithLiveCurrentYear usage:
   - call buildAnnualArraysFromTXT() first (past years)
   - then updateLiveAndAnnualCounts() will overwrite the current year bar using live peaks from IV.
*/
const _updateLiveAndAnnualCounts_original = updateLiveAndAnnualCounts;
updateLiveAndAnnualCounts = async function(){
  // Ensure annual arrays exist from TXT (past years)
  buildAnnualArraysFromTXT();
  renderAnnual();

  // Now run the original live routine, which computes YTD peak counts and overwrites current year
  await _updateLiveAndAnnualCounts_original();
};

/* ---------- Wire TXT loader into boot() ---------- */
const _boot_original = boot;
boot = async function(){
  updateUnitsAndBadges();
  minElevEl.value = THRESH[DISPLAY_DATUM].minorLow.toFixed(2);
  renderTopTen();

  // Load TXT first, then hydrate dependent sections
  const results = await Promise.allSettled([
    updateAlerts(),
    (async ()=>{
      await loadDailyTidesFromTXT();      // PART 1 loader
      hydrateHistoricFromTXT();           // historic filter backing array
      updateMonthAveragesFromTXT();       // monthly averages from TXT
      buildAnnualArraysFromTXT();         // annual bars base (past years)
      renderAnnual();
    })(),
    updateLiveAndAnnualCounts(),          // live current year + live stage + daily range
    updateTimeseries()                   // 24h obs + 72h pred (we'll troubleshoot in Part 3)
  ]);

  // If live still missing, make status explicit
  if(!STATE.lastNavd){
    stageTextEl.textContent="LIVE DATA UNAVAILABLE";
    lastPill.textContent="Last updated: —";
    curFtEl.textContent="—";
    curMetaEl.textContent="Updated: —";
  }

  // If TXT failed, report it in the monthly meta (silent but visible)
  const txtRes = results[1];
  if(txtRes.status === "rejected"){
    console.error("TXT load failed:", txtRes.reason);
    monthAvgMeta.textContent = "TXT load failed (check data/daily_tides_navd88.txt path/format).";
    histMeta.textContent = "TXT load failed (historic filter unavailable).";
  }
};

/* Keep your existing boot() call & interval as-is */
/* ===========================
   PART 3/4 — Fix “Where are the predictions?”
   and make the 24h obs chart NOT interpolate across gaps
   (and NOT hide the observed line if it goes missing).

   What’s actually happening (most common):
   - USGS observed fetch returns 0 points (wrong/unsupported param),
     so your “Observed” series becomes all-null and effectively invisible.
   - NOAA predictions may also fail (CORS, station mismatch, or bad date params),
     but your code currently swallows the error and shows nothing.

   This part does TWO things:
   1) Make observed series robust by selecting the *first available* 15-min
      series from a prioritized param list (PRIMARY, fallback, and “any”).
   2) Make NOAA failures visible in the UI and force a distinct forecast line.
   =========================== */

/* ---------- A. Stronger 15-min observed fetch (robust parameter selection) ---------- */
/* We keep your existing PRIMARY_PARAM / FALLBACK_PARAM constants,
   but add a list of candidates and a “first working series” picker.
*/
const OBS_PARAM_CANDIDATES = [
  PRIMARY_PARAM,  // 72279 (your current “tidal elevation”)
  FALLBACK_PARAM, // 00065 (gage height)
  "00060"         // discharge (won’t be valid here but harmless as a last try)
];

/* Extract series from ALL timeSeries (not just [0]), so we can pick any that has data */
function extractAllSeries(json){
  const tss = json?.value?.timeSeries || [];
  const out = [];
  for(const ts of tss){
    const vals = ts?.values?.[0]?.value || [];
    const arr = vals
      .map(v=>({t:v.dateTime, ft:+v.value}))
      .filter(p=>Number.isFinite(p.ft) && p.t);
    if(arr.length) out.push(arr);
  }
  return out;
}

async function fetchIV_anyParam({startISO=null,endISO=null,period=null,parameterCd=null}={}){
  const url=new URL("https://waterservices.usgs.gov/nwis/iv/");
  url.searchParams.set("format","json");
  url.searchParams.set("sites",USGS_SITE);
  url.searchParams.set("siteStatus","all");
  url.searchParams.set("agencyCd","USGS");
  if(parameterCd) url.searchParams.set("parameterCd",parameterCd);
  if(period) url.searchParams.set("period",period);
  if(startISO) url.searchParams.set("startDT",startISO);
  if(endISO) url.searchParams.set("endDT",endISO);
  const res=await fetch(url.toString(),{cache:"no-store"});
  if(!res.ok) throw new Error("USGS IV failed "+res.status);
  return res.json();
}

/* NEW: robust observed fetch:
   - try candidate params in order
   - if still empty, request WITHOUT parameterCd and choose any non-empty series
*/
async function fetchObserved15minRobust({startISO,endISO}){
  // Try candidate params explicitly
  for(const param of OBS_PARAM_CANDIDATES){
    try{
      const j = await fetchIV_anyParam({startISO,endISO,parameterCd:param});
      const series = extractSeries(j); // your original (first series)
      if(series.length) return series;
      // if first series empty but other series exist, try them:
      const any = extractAllSeries(j);
      if(any.length) return any[0];
    }catch(e){
      // keep trying next
    }
  }

  // Final attempt: no parameterCd at all; take the first non-empty series
  const j = await fetchIV_anyParam({startISO,endISO});
  const any = extractAllSeries(j);
  if(any.length) return any[0];

  return [];
}

/* ---------- B. Make NOAA predictions failures visible + improve request ---------- */
/* We keep your COOPS station, but we:
   - show an error note if NOAA fails
   - enforce begin/end dates that are valid
*/
async function fetchCOOPSPredictions_MLLW_safe({beginDateISO=null, hours=72}={}){
  try{
    const start = beginDateISO ? new Date(beginDateISO) : new Date();
    const begin = roundUpTo6Min(start);
    const end = new Date(begin.getTime()+hours*3600*1000);

    const url=new URL("https://api.tidesandcurrents.noaa.gov/api/prod/datagetter");
    url.searchParams.set("product","predictions");
    url.searchParams.set("application",COOPS_APP);
    url.searchParams.set("station",COOPS_STATION);
    url.searchParams.set("datum",COOPS_DATUM);
    url.searchParams.set("time_zone",COOPS_TZ); // gmt
    url.searchParams.set("units","english");
    url.searchParams.set("interval",COOPS_INTERVAL); // 6-min
    url.searchParams.set("format","json");
    url.searchParams.set("begin_date",toCOOPSLocalStringGMT(begin));
    url.searchParams.set("end_date",toCOOPSLocalStringGMT(end));

    const res=await fetch(url.toString(),{cache:"no-store"});
    if(!res.ok){
      throw new Error(`NOAA predictions HTTP ${res.status}`);
    }
    const j=await res.json();
    if(j?.error){
      throw new Error(`NOAA predictions error: ${j.error?.message || JSON.stringify(j.error)}`);
    }
    const arr=j?.predictions||[];
    const parsed = arr.map(p=>{
      const t = p.t.replace(" ","T")+":00Z"; // time_zone=gmt -> UTC
      return {t, ft:+p.v}; // ft in MLLW
    }).filter(p=>Number.isFinite(p.ft) && p.t);

    return { data: parsed, err: null };
  }catch(e){
    return { data: [], err: e?.message || String(e) };
  }
}

/* ---------- C. Ensure Chart.js never interpolates across missing observed points ---------- */
/* You already set spanGaps:false in Part 2 changes, but we ensure the OBS dataset uses
   a fixed 15-min grid and inserts nulls where missing.
*/
function updateTsChartFromState(){
  if(!STATE.obs24Navd || !STATE.pred72Mllw) return;

  const endISO = nowISO();
  const startISO = new Date(new Date(endISO).getTime() - 24*3600*1000).toISOString();

  // Fixed 15-min grid for OBS (NAVD), then convert to display
  const grid = buildFixedGrid15Min(STATE.obs24Navd, startISO, endISO);
  const obsLabels = grid.labels;
  const obsValsDisplay = grid.values.map(v => (v===null ? null : toDisplayFtFromNavd(v)));

  // Forecast (MLLW) to display
  const fc = STATE.pred72Mllw.map(p=>({t:p.t, ft:toDisplayFtFromMllw(p.ft)}));

  const labels=[...obsLabels, ...fc.map(p=>p.t)];
  const obsData=[...obsValsDisplay, ...Array(fc.length).fill(null)];
  const fcData=[...Array(obsLabels.length).fill(null), ...fc.map(p=>p.ft)];

  ensureTsChart();
  tsChart.data.labels = labels;
  tsChart.data.datasets[0].data = obsData;
  tsChart.data.datasets[1].data = fcData;

  // Always keep gaps
  tsChart.data.datasets[0].spanGaps = false;
  tsChart.data.datasets[1].spanGaps = false;

  tsChart.options.scales.x.ticks.callback = buildDailyTickCallbackSkipFirstDay(labels);
  tsChart.options.scales.y.title.text = unitText();
  tsChart.update();
}

/* ---------- D. Update updateTimeseries() to use robust observed + safe NOAA ---------- */
updateTimeseries = async function(){
  const end = new Date();
  const start = new Date(end.getTime() - 24*3600*1000);

  // OBS: robust selection
  const obs = await fetchObserved15minRobust({startISO:start.toISOString(), endISO:end.toISOString()});
  STATE.obs24Navd = obs;

  // If observed is missing, show it explicitly
  if(!obs.length){
    fcNote.textContent = "Observed series unavailable (USGS returned no 15-min points).";
  }

  // Forecast: begin at last observed timestamp if possible, else now
  const lastObsTime = obs.length ? obs[obs.length-1].t : null;

  const fcRes = await fetchCOOPSPredictions_MLLW_safe({beginDateISO:lastObsTime || new Date().toISOString(), hours:72});
  STATE.pred72Mllw = fcRes.data;

  if(fcRes.err){
    // Make NOAA issue visible instead of silent
    fcNote.textContent = `NOAA predictions unavailable: ${fcRes.err}`;
  }else if(!STATE.pred72Mllw.length){
    fcNote.textContent = "NOAA predictions returned no points.";
  }else{
    // Clear note if both exist
    if(obs.length) fcNote.textContent = "";
  }

  updateTsChartFromState();
};
/* ===========================
   PART 4/4 — Final integration + critical fixes:
   1) Annual flooding bars: TXT for completed years + live current year
      (NO double counting; no reliance on hardcoded arrays)
   2) Historic tides filter: ensure it is fed ONLY by TXT
   3) Monthly averages: ensure it is fed ONLY by TXT
   4) Boot order + graceful fallbacks
   =========================== */

/* ---------- 1) Annual flooding bars from TXT (completed years) + live current year ---------- */

/* Counts “event floods” from TXT events (High + Low-High) by NAVD thresholds */
function countAnnualFloodsFromTXT(eventsNavd){
  const T = THRESH.NAVD88;
  const byYear = new Map(); // y -> {minor, moderate, major}
  for(const e of eventsNavd){
    const y = e.y || (new Date(e.t)).getUTCFullYear();
    if(!byYear.has(y)) byYear.set(y,{minor:0, moderate:0, major:0});
    if(e.ft >= T.minorLow){
      const rec = byYear.get(y);
      if(e.ft >= T.majorLow) rec.major++;
      else if(e.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }
  return byYear;
}

/* Builds chart arrays from TXT for all years present EXCEPT current year will be overwritten by live */
function buildAnnualArraysFromTXT_completedYears(){
  const {y:curYear}=getESTParts(new Date());

  if(!HIGH_TIDES_NAVD || !HIGH_TIDES_NAVD.length){
    YEARS = [];
    annualMinor = [];
    annualModerate = [];
    annualMajor = [];
    return;
  }

  const byYear = countAnnualFloodsFromTXT(HIGH_TIDES_NAVD);

  const years = Array.from(byYear.keys()).sort((a,b)=>a-b);

  // Ensure current year is included (even if TXT has no entry yet)
  if(!years.includes(curYear)) years.push(curYear);

  YEARS = years;
  annualMinor = YEARS.map(y=> byYear.get(y)?.minor ?? 0);
  annualModerate = YEARS.map(y=> byYear.get(y)?.moderate ?? 0);
  annualMajor = YEARS.map(y=> byYear.get(y)?.major ?? 0);
}

/* Live current-year overwrite:
   We keep your “two floods/day possible” peak-counter for IV (15-min) YTD,
   and we overwrite the current year bar ONLY.
*/
function overwriteCurrentYearBarWithLiveCounts(liveCounts){
  if(!liveCounts) return;
  const {y:curYear}=getESTParts(new Date());
  const idx = YEARS.indexOf(curYear);
  if(idx < 0) return;
  annualMinor[idx] = liveCounts.minor;
  annualModerate[idx] = liveCounts.moderate;
  annualMajor[idx] = liveCounts.major;
}

/* Replace the annual builder path in updateLiveAndAnnualCounts:
   - First build arrays from TXT
   - Then compute live YTD counts and overwrite current year bar
*/
updateLiveAndAnnualCounts = async function(){
  // (A) Base annual series from TXT (completed years)
  buildAnnualArraysFromTXT_completedYears();
  renderAnnual();

  // (B) Original live logic (current water level, daily range, stage, near-match)
  //     + compute YTD peak counts from IV (15-min) and overwrite current year annual bar
  const {y:curYear}=getESTParts(new Date());
  const startISO = startOfYearEST_ISO(curYear);
  const endISO = nowISO();

  const ytd = await fetchWithFallback({startISO, endISO});
  if(!ytd.length) throw new Error("no live data");

  STATE.ytdNavd = ytd;
  STATE.lastNavd = ytd[ytd.length-1];

  const curDisp = toDisplayFtFromNavd(STATE.lastNavd.ft);
  curFtEl.textContent = curDisp.toFixed(2);
  curMetaEl.textContent = "Updated: " + fmtESTFull(STATE.lastNavd.t);
  lastPill.textContent = "Last updated: " + fmtESTFull(STATE.lastNavd.t);
  setStage(STATE.lastNavd.ft);
  await updateNearMetaIfNeeded(STATE.lastNavd.ft, STATE.lastNavd.t);

  const today = sliceAfter(ytd, startOfTodayEST_ISO());
  STATE.todayNavd = today;
  if(today.length){
    const dmx=maxPoint(today), dmn=minPoint(today);
    dayMaxFtEl.textContent = toDisplayFtFromNavd(dmx.ft).toFixed(2);
    dayMinFtEl.textContent = toDisplayFtFromNavd(dmn.ft).toFixed(2);
    dayRangeMeta.textContent = `Max @ ${fmtESTFull(dmx.t)} · Min @ ${fmtESTFull(dmn.t)}`;
  }else{
    dayMaxFtEl.textContent="—";
    dayMinFtEl.textContent="—";
    dayRangeMeta.textContent="—";
  }

  // (C) Current-year YTD counts (two floods/day possible) from 15-min IV peaks
  const counts = countFloodPeaks_NAVD(ytd);
  overwriteCurrentYearBarWithLiveCounts(counts);
  renderAnnual();
};

/* ---------- 2) Historic tides filter: ensure it’s TXT-only ---------- */
/* We fully retire events.json for historical filter.
   HIGH_TIDES_NAVD is hydrated from DAILY_EVENTS_NAVD only.
*/
async function initTXTBackedHistory(){
  await loadDailyTidesFromTXT();
  hydrateHistoricFromTXT();
}

/* ---------- 3) Monthly averages: TXT-only ---------- */
function initMonthlyFromTXT(){
  updateMonthAveragesFromTXT();
}

/* ---------- 4) Boot: enforce correct order and make failures visible ---------- */
boot = async function(){
  updateUnitsAndBadges();
  minElevEl.value = THRESH[DISPLAY_DATUM].minorLow.toFixed(2);
  renderTopTen();

  // Load TXT first (past), then run live (present/future)
  const results = await Promise.allSettled([
    updateAlerts(),
    (async ()=>{
      await initTXTBackedHistory();   // loads TXT + hydrates HIGH_TIDES_NAVD + applies filter
      initMonthlyFromTXT();           // monthly averages from TXT
      buildAnnualArraysFromTXT_completedYears(); // annual base from TXT
      renderAnnual();
    })(),
    updateLiveAndAnnualCounts(),      // overwrites current year bar + live stage + daily range
    updateTimeseries()                // robust obs + visible NOAA predictions errors
  ]);

  // If TXT failed, explicitly show that the “past” features are unavailable
  const txtRes = results[1];
  if(txtRes.status === "rejected"){
    console.error("TXT init failed:", txtRes.reason);
    histMeta.textContent = "TXT load failed (historic filter unavailable). Check data/daily_tides_navd88.txt path/format.";
    monthAvgMeta.textContent = "TXT load failed (monthly averages unavailable). Check data/daily_tides_navd88.txt path/format.";
  }

  // If live failed, make it explicit (but keep past features working)
  const liveRes = results[2];
  if(liveRes.status === "rejected"){
    console.error("Live init failed:", liveRes.reason);
    stageTextEl.textContent="LIVE DATA UNAVAILABLE";
    lastPill.textContent="Last updated: —";
    curFtEl.textContent="—";
    curMetaEl.textContent="Updated: —";
  }
};

/* Keep your existing boot() invocation and refresh interval as-is:
   boot().catch(...)
   setInterval(...)
*/
