<script>
/* ========= SCRIPT (Part 1/2) ========= */

/* Fixed EST year-round (UTC-5). */
const TZ="Etc/GMT+5";

/* Datum toggle */
let DISPLAY_DATUM = "MLLW"; // "MLLW" or "NAVD88"

/* ============================================================
DATUM FIX
NAVD88 = MLLW + (+3.41)
============================================================ */
const OFFSET_NAVD_FROM_MLLW_FT = +3.41;
function mllwToNavd(ft){ return ft + OFFSET_NAVD_FROM_MLLW_FT; }
function navdToMllw(ft){ return ft - OFFSET_NAVD_FROM_MLLW_FT; }

/* =========================
USGS observed (15-min IV)
========================= */
const USGS_SITE="01412150";

/* Water level ONLY (tide elevation NAVD88). */
const USGS_PARAM_PRIMARY = "72279";
const USGS_PARAM_CSV = USGS_PARAM_PRIMARY;

/* =========================
NOAA CO-OPS predictions
Request 6-min then RESAMPLE to 15-min
========================= */
const COOPS_STATION="8535055";
const COOPS_APP="cupajoe.live";
const COOPS_DATUM="MLLW";
const COOPS_INTERVAL="6";
const COOPS_TZ="gmt";

/* Flood thresholds */
const THRESH = {
  MLLW:  { minorLow:7.60, moderateLow:8.60, majorLow:9.60 },
  NAVD88:{ minorLow:4.19, moderateLow:5.19, majorLow:6.19 }
};

/* Peak counting settings */
const PEAK_MIN_SEP_MINUTES = 300;

/* NWS alerts point */
const ALERT_POINT={lat:39.2325, lon:-75.0380};

/* TXT daily tides file */
const DAILY_TIDES_TXT_FILE = "daily_tides_navd88.txt";
const TXT_PATH_CANDIDATES = [
  `data/${DAILY_TIDES_TXT_FILE}`,
  `./data/${DAILY_TIDES_TXT_FILE}`,
  `../data/${DAILY_TIDES_TXT_FILE}`,
  `/data/${DAILY_TIDES_TXT_FILE}`
];

let DAILY_TIDES_TXT_URL = TXT_PATH_CANDIDATES[0];

/* TXT columns (NAVD88 daily stats for parameter 72279) */
const COL_DAILY_HIGH  = "239251_72279_00021";
const COL_DAILY_LOWHI = "239252_72279_00022";

/* TOP TEN (stored as TRUE MLLW) */
const TOP_TEN_MLLW=[
  {date:"10-29-2012", ft:7.03},
  {date:"11-25-1950", ft:6.60},
  {date:"04-16-2011", ft:5.80},
  {date:"08-04-2020", ft:5.67},
  {date:"08-27-2011", ft:5.60},
  {date:"01-23-2016", ft:5.58},
  {date:"04-19-2022", ft:5.50},
  {date:"08-21-2025", ft:5.49},
  {date:"10-26-2019", ft:5.41},
  {date:"03-09-2024", ft:5.39}
];

/* DOM */
const $=id=>document.getElementById(id);

const curFtEl=$("curFt"), curMetaEl=$("curMeta");
const dayMaxFtEl=$("dayMaxFt"), dayMinFtEl=$("dayMinFt"), dayRangeMeta=$("dayRangeMeta");
const stageTextEl=$("stageText"), stageDotEl=$("stageDot");
const lastPill=$("lastPill");
const alertBanner=$("alertBanner"), alertTitle=$("alertTitle"), alertBody=$("alertBody");

const topTenBody=$("topTenBody");
const topTenUnitTh=$("topTenUnitTh");
const fcNote=$("fcNote");
const txtNote=$("txtNote");

const histBody=$("histBody"), histMeta=$("histMeta"), histUnitTh=$("histUnitTh");
const minElevEl=$("minElev"), sortModeEl=$("sortMode");
const minorBadge=$("minorBadge"), moderateBadge=$("moderateBadge"), majorBadge=$("majorBadge");
const datumBtn=$("datumBtn");

const monthAvgMeta=$("monthAvgMeta"), monthAvgBody=$("monthAvgBody");

/* If ANY JS error happens, show it in the UI so you’re not blind */
window.addEventListener("error",(e)=>{
  console.error("JS error:", e?.message || e);
  if(stageTextEl) stageTextEl.textContent="SCRIPT ERROR (open Console)";
});
window.addEventListener("unhandledrejection",(e)=>{
  console.error("Unhandled promise:", e?.reason || e);
  if(stageTextEl) stageTextEl.textContent="SCRIPT ERROR (open Console)";
});

/* Formatters */
const fmtFull = new Intl.DateTimeFormat("en-US",{ timeZone:TZ,year:"numeric",month:"short",day:"2-digit", hour:"2-digit",minute:"2-digit",hour12:true });
const fmtDay = new Intl.DateTimeFormat("en-US",{timeZone:TZ,month:"short",day:"2-digit"});
const fmtPartsYMD = new Intl.DateTimeFormat("en-US",{timeZone:TZ,year:"numeric",month:"2-digit",day:"2-digit"});
const fmtMonthName = new Intl.DateTimeFormat("en-US",{timeZone:TZ,month:"short"});

function fmtESTFull(iso){ return fmtFull.format(new Date(iso)); }
function fmtESTDay(iso){ return fmtDay.format(new Date(iso)); }

function getESTParts(date=new Date()){
  const p=fmtPartsYMD.formatToParts(date);
  return { y:+p.find(x=>x.type==="year").value, m:+p.find(x=>x.type==="month").value, d:+p.find(x=>x.type==="day").value };
}

function startOfTodayEST_ISO(){
  const {y,m,d}=getESTParts(new Date());
  return new Date(Date.UTC(y,m-1,d,5,0,0)).toISOString();
}
function startOfYearEST_ISO(y){ return new Date(Date.UTC(y,0,1,5,0,0)).toISOString(); }
function nowISO(){ return new Date().toISOString(); }

/* Datum helpers */
function datumLabel(){ return DISPLAY_DATUM; }
function unitText(){ return "ft " + datumLabel(); }
function toDisplayFtFromNavd(navd){ return (DISPLAY_DATUM==="MLLW") ? navdToMllw(navd) : navd; }
function toDisplayFtFromMllw(mllw){ return (DISPLAY_DATUM==="MLLW") ? mllw : mllwToNavd(mllw); }
function fromDisplayToNavd(displayFt){ return (DISPLAY_DATUM==="MLLW") ? mllwToNavd(displayFt) : displayFt; }

/* Stage classify uses NAVD thresholds */
function classifyByNavd(navdFt){
  const T = THRESH.NAVD88;
  if(navdFt>=T.majorLow)    return {label:"MAJOR FLOODING",    color:"var(--major)",    glow:"rgba(167,139,250,.22)", short:"Major"};
  if(navdFt>=T.moderateLow) return {label:"MODERATE FLOODING", color:"var(--moderate)", glow:"rgba(251,113,133,.22)", short:"Moderate"};
  if(navdFt>=T.minorLow)    return {label:"MINOR FLOODING",    color:"var(--minor)",    glow:"rgba(251,191,36,.22)", short:"Minor"};
  return {label:"BELOW FLOOD STAGE", color:"var(--ok)", glow:"rgba(45,212,191,.18)", short:"Below"};
}
function stageTagByNavd(navdFt){
  const c=classifyByNavd(navdFt);
  return {txt:c.short, c:c.color};
}
function setStage(navdFt){
  const c=classifyByNavd(navdFt);
  if(stageTextEl) stageTextEl.textContent=c.label;
  if(stageDotEl){
    stageDotEl.style.background=c.color;
    stageDotEl.style.boxShadow = `0 0 0 4px ${c.glow}`;
  }
}

function updateUnitsAndBadges(){
  document.querySelectorAll("[data-unit]").forEach(el=>{ el.textContent = "ft " + datumLabel(); });
  if(topTenUnitTh) topTenUnitTh.textContent = "Height (" + unitText() + ")";
  if(histUnitTh) histUnitTh.textContent = "Peak (" + unitText() + ")";

  const T = THRESH[DISPLAY_DATUM];
  if(minorBadge) minorBadge.textContent    = `${T.minorLow.toFixed(2)}–${T.moderateLow.toFixed(2)}`;
  if(moderateBadge) moderateBadge.textContent = `${T.moderateLow.toFixed(2)}–${T.majorLow.toFixed(2)}`;
  if(majorBadge) majorBadge.textContent    = `≥ ${T.majorLow.toFixed(2)}`;

  if(datumBtn) datumBtn.textContent = "Datum: " + datumLabel();
}

/* Simple helpers */
function maxPoint(arr){ return arr.reduce((a,b)=>b.ft>a.ft?b:a, arr[0]); }
function minPoint(arr){ return arr.reduce((a,b)=>b.ft<a.ft?b:a, arr[0]); }
function setTXTStatus(msg){ if(txtNote) txtNote.textContent = msg; }

/* Fetch helper */
async function tryFetchText(url){
  try{
    const res = await fetch(url, { cache:"no-store" });
    if(!res.ok) return {ok:false, url, status:res.status, text:null};
    return {ok:true, url, status:res.status, text: await res.text()};
  }catch(e){
    return {ok:false, url, status:"NETWORK", text:null, err:(e?.message||String(e))};
  }
}

async function resolveDailyTidesTXTUrl(){
  const failures=[];
  for(const candidate of TXT_PATH_CANDIDATES){
    const r = await tryFetchText(candidate);
    if(r.ok){
      DAILY_TIDES_TXT_URL = candidate;
      setTXTStatus(`TXT OK: loaded ${candidate}`);
      return {url:candidate, text:r.text};
    }else{
      failures.push(`${candidate} (${r.status}${r.err?`: ${r.err}`:""})`);
    }
  }
  setTXTStatus("TXT ERROR: could not load daily tides file. Tried: " + failures.join(" · "));
  throw new Error("TXT not found. Tried: " + failures.join(" | "));
}

/* Parsed daily rows + expanded events */
let DAILY_TIDES = [];
let DAILY_EVENTS_NAVD = [];

/* Parse USGS tab-delimited TXT */
function parseUSGSDailyTidesTXT(text){
  const lines = text.split(/\r?\n/);

  let headerLineIndex = -1;
  for(let i=0;i<lines.length;i++){
    const ln = lines[i];
    if(!ln) continue;
    if(ln.startsWith("#")) continue;
    if(ln.startsWith("agency_cd\t")) { headerLineIndex = i; break; }
  }
  if(headerLineIndex < 0) throw new Error("TXT parse error: could not find header row starting with 'agency_cd'.");

  const header = lines[headerLineIndex].split("\t");
  const idxDate = header.indexOf("datetime");
  const idxHigh = header.indexOf(COL_DAILY_HIGH);
  const idxLowHi = header.indexOf(COL_DAILY_LOWHI);

  if(idxDate < 0 || idxHigh < 0 || idxLowHi < 0){
    const missing = [
      idxDate < 0 ? "datetime" : null,
      idxHigh < 0 ? COL_DAILY_HIGH : null,
      idxLowHi < 0 ? COL_DAILY_LOWHI : null
    ].filter(Boolean).join(" / ");
    setTXTStatus(`TXT ERROR: missing column(s): ${missing}`);
    throw new Error("TXT missing required columns: " + missing);
  }

  const out=[];
  for(let i=headerLineIndex+1;i<lines.length;i++){
    const ln = lines[i];
    if(!ln) continue;
    if(ln.startsWith("#")) continue;

    const parts = ln.split("\t");
    if(parts.length < header.length) continue;

    const dtStr = (parts[idxDate] || "").trim();
    if(!/^\d{4}-\d{2}-\d{2}$/.test(dtStr)) continue;

    const y = +dtStr.slice(0,4);
    const m = +dtStr.slice(5,7);
    const d = +dtStr.slice(8,10);

    const highStr  = (parts[idxHigh] || "").trim();
    const lowhiStr = (parts[idxLowHi] || "").trim();

    const highNavd  = highStr  === "" ? null : +highStr;
    const lowhiNavd = lowhiStr === "" ? null : +lowhiStr;

    if((highNavd!==null && Number.isFinite(highNavd)) || (lowhiNavd!==null && Number.isFinite(lowhiNavd))){
      out.push({y,m,d, highNavd:Number.isFinite(highNavd)?highNavd:null, lowhiNavd:Number.isFinite(lowhiNavd)?lowhiNavd:null});
    }
  }
  out.sort((a,b)=> (a.y-b.y) || (a.m-b.m) || (a.d-b.d));
  return out;
}

function buildDailyEventsFromDailyTides(rows){
  const ev=[];
  for(const r of rows){
    const t = new Date(Date.UTC(r.y, r.m-1, r.d, 17, 0, 0)).toISOString(); // noon EST as 17:00Z
    if(r.highNavd!==null)  ev.push({t, ft:r.highNavd,  kind:"High",     y:r.y, m:r.m, d:r.d});
    if(r.lowhiNavd!==null) ev.push({t, ft:r.lowhiNavd, kind:"Low-High", y:r.y, m:r.m, d:r.d});
  }
  ev.sort((a,b)=>new Date(a.t)-new Date(b.t));
  return ev;
}

async function loadDailyTidesFromTXT(){
  const {url, text} = await resolveDailyTidesTXTUrl();
  DAILY_TIDES = parseUSGSDailyTidesTXT(text);
  DAILY_EVENTS_NAVD = buildDailyEventsFromDailyTides(DAILY_TIDES);
  setTXTStatus(`TXT OK: ${DAILY_TIDES.length.toLocaleString()} daily rows (${DAILY_EVENTS_NAVD.length.toLocaleString()} events) from ${url}`);
}

/* USGS IV fetch */
async function fetchIV({startISO=null,endISO=null,period=null}={}){
  const url=new URL("https://waterservices.usgs.gov/nwis/iv/");
  url.searchParams.set("format","json");
  url.searchParams.set("sites",USGS_SITE);
  url.searchParams.set("parameterCd",USGS_PARAM_CSV);
  url.searchParams.set("siteStatus","all");
  url.searchParams.set("agencyCd","USGS");
  if(period) url.searchParams.set("period",period);
  if(startISO) url.searchParams.set("startDT",startISO);
  if(endISO) url.searchParams.set("endDT",endISO);
  const res=await fetch(url.toString(),{cache:"no-store"});
  if(!res.ok) throw new Error("USGS IV failed "+res.status);
  return res.json();
}

function getTsParamCode(ts){
  return ts?.variable?.variableCode?.[0]?.value || null;
}
function extractWaterLevelSeries_NAVD88(json){
  const tss = json?.value?.timeSeries || [];
  const candidates = tss.filter(ts => getTsParamCode(ts) === USGS_PARAM_PRIMARY);

  if(!candidates.length){
    const have = tss.map(getTsParamCode).filter(Boolean);
    throw new Error(
      `USGS returned no water-level series for parameter ${USGS_PARAM_PRIMARY}. ` +
      (have.length ? `Returned codes: ${[...new Set(have)].join(", ")}` : "No codes returned.")
    );
  }

  let bestPts = [];
  for(const ts of candidates){
    const vals = ts?.values?.[0]?.value || [];
    const pts = vals
      .map(v => ({ t: v.dateTime, ft: Number(v.value) }))
      .filter(p => p.t && Number.isFinite(p.ft));
    if(pts.length > bestPts.length) bestPts = pts;
  }
  return bestPts;
}

async function fetchObservedSeries({startISO=null,endISO=null,period=null}={}){
  const j = await fetchIV({startISO,endISO,period});
  return extractWaterLevelSeries_NAVD88(j);
}

/* NOAA helpers */
function toCOOPSLocalStringGMT(date){
  const parts = new Intl.DateTimeFormat("en-US",{
    timeZone:"UTC", year:"numeric",month:"2-digit",day:"2-digit", hour:"2-digit",minute:"2-digit", hour12:false
  }).formatToParts(date);
  const y=parts.find(p=>p.type==="year").value;
  const m=parts.find(p=>p.type==="month").value;
  const d=parts.find(p=>p.type==="day").value;
  const hh=parts.find(p=>p.type==="hour").value;
  const mm=parts.find(p=>p.type==="minute").value;
  return `${y}${m}${d} ${hh}:${mm}`;
}
function roundUpTo6Min(d){
  const step = 6*60*1000;
  return new Date(Math.ceil(d.getTime()/step)*step);
}

async function fetchCOOPSPredictions_MLLW({beginDateISO=null, hours=72}={}){
  const start = beginDateISO ? new Date(beginDateISO) : new Date();
  const begin = roundUpTo6Min(start);
  const end = new Date(begin.getTime()+hours*3600*1000);

  const url=new URL("https://api.tidesandcurrents.noaa.gov/api/prod/datagetter");
  url.searchParams.set("product","predictions");
  url.searchParams.set("application",COOPS_APP);
  url.searchParams.set("station",COOPS_STATION);
  url.searchParams.set("datum",COOPS_DATUM);
  url.searchParams.set("time_zone",COOPS_TZ);
  url.searchParams.set("units","english");
  url.searchParams.set("interval",COOPS_INTERVAL);
  url.searchParams.set("format","json");
  url.searchParams.set("begin_date",toCOOPSLocalStringGMT(begin));
  url.searchParams.set("end_date",toCOOPSLocalStringGMT(end));

  const res=await fetch(url.toString(),{cache:"no-store"});
  if(!res.ok) throw new Error("COOPS predictions failed "+res.status);
  const j=await res.json();
  if(j?.error) throw new Error(j.error?.message || "NOAA error");

  const arr=j?.predictions||[];
  return arr.map(p=>({ t: p.t.replace(" ","T")+":00Z", ft:+p.v }))
            .filter(p=>Number.isFinite(p.ft) && p.t);
}

/* 15-min resampling */
function resampleTo15Min(points){
  if(!points || !points.length) return [];
  const step = 15*60*1000;
  const half = step/2;

  const pts = [...points]
    .map(p=>({t:p.t, ft:p.ft, ms:new Date(p.t).getTime()}))
    .filter(p=>Number.isFinite(p.ms))
    .sort((a,b)=>a.ms-b.ms);

  const start = Math.floor(pts[0].ms/step)*step;
  const end   = Math.ceil(pts[pts.length-1].ms/step)*step;

  let j=0;
  const out=[];
  for(let t=start; t<=end; t+=step){
    while(j<pts.length && pts[j].ms < t-half) j++;

    let best=null;
    for(let k=j; k<pts.length; k++){
      const dt = Math.abs(pts[k].ms - t);
      if(dt > half) break;
      if(pts[k].ft===null || pts[k].ft===undefined || Number.isNaN(pts[k].ft)) continue;
      if(!best || dt < best.dt) best = {dt, p:pts[k]};
    }

    if(best){
      out.push({ t:new Date(t).toISOString(), ft:best.p.ft });
    }else{
      out.push({ t:new Date(t).toISOString(), ft:null });
    }
  }
  return out;
}

/* Alerts */
async function updateAlerts(){
  try{
    const url = `https://api.weather.gov/alerts/active?point=${ALERT_POINT.lat},${ALERT_POINT.lon}`;
    const res=await fetch(url,{cache:"no-store"});
    if(!res.ok) throw new Error("alerts "+res.status);
    const j=await res.json();
    const feats=j?.features||[];
    const coastal=feats.find(f=>((f?.properties?.event||"").toLowerCase().includes("coastal flood")));
    if(!coastal){ if(alertBanner) alertBanner.style.display="none"; return; }
    const p=coastal.properties||{};
    if(alertTitle) alertTitle.textContent=p.event||"Coastal Flood Alert";
    const ends=p.ends?fmtESTFull(p.ends):(p.expires?fmtESTFull(p.expires):"—");
    if(alertBody) alertBody.textContent=(p.headline?p.headline+" · ":"")+"Ends: "+ends;
    if(alertBanner) alertBanner.style.display="block";
  }catch{
    if(alertBanner) alertBanner.style.display="none";
  }
}

/* Top ten */
function renderTopTen(){
  if(!topTenBody) return;
  topTenBody.innerHTML="";
  TOP_TEN_MLLW.forEach((r,i)=>{
    const navd = mllwToNavd(r.ft);
    const tag = stageTagByNavd(navd);
    const disp = toDisplayFtFromMllw(r.ft);
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><b>#${i+1}</b></td>
      <td>${r.date}</td>
      <td><b>${disp.toFixed(2)}</b></td>
      <td><span class="tag"><span class="chip" style="background:${tag.c}"></span>${tag.txt}</span></td>
    `;
    topTenBody.appendChild(tr);
  });
}

/* Fixed 15-min grid builder */
function buildFixedGrid15Min(seriesNavd, startISO, endISO){
  const start = new Date(startISO).getTime();
  const end = new Date(endISO).getTime();
  const step = 15*60*1000;

  const m = new Map();
  for(const p of (seriesNavd||[])){
    const t = new Date(p.t).getTime();
    if(Number.isNaN(t)) continue;
    const rounded = Math.round(t/step)*step;
    m.set(rounded, p.ft);
  }

  const labels=[], values=[];
  const s0 = Math.floor(start/step)*step;
  const e0 = Math.ceil(end/step)*step;

  for(let t=s0; t<=e0; t+=step){
    labels.push(new Date(t).toISOString());
    values.push(m.has(t) ? m.get(t) : null);
  }
  return {labels, values};
}

/* Core state */
let HIGH_TIDES_NAVD=[];
let annualChart=null, tsChart=null, monthAvgChart=null;
let YEARS=[], annualMinor=[], annualModerate=[], annualMajor=[];

const STATE = { lastNavd:null, ytdNavd:null, todayNavd:null, obs24Navd:null, pred72Mllw:null };

function sliceAfter(series, startISO){
  const s = new Date(startISO).getTime();
  return (series||[]).filter(p=>new Date(p.t).getTime()>=s);
}

function colorForFtDisplay(ftDisplay){
  const T = THRESH[DISPLAY_DATUM];
  if(ftDisplay>=T.majorLow)    return "rgba(167,139,250,.95)";
  if(ftDisplay>=T.moderateLow) return "rgba(251,113,133,.95)";
  if(ftDisplay>=T.minorLow)    return "rgba(251,191,36,.95)";
  return "rgba(45,212,191,.90)";
}

/* Flood strip plugin */
const floodStripPlugin = {
  id: "floodStripPlugin",
  beforeDatasetsDraw(chart){
    const {ctx, chartArea} = chart;
    if(!chartArea) return;

    const pad = 2;
    const h = 6;
    const gap = 2;

    const x0 = chartArea.left;
    const w  = chartArea.right - chartArea.left;
    const yTop = chartArea.top + pad;

    const strips = [
      {y:yTop,                 color:"rgba(251,191,36,.95)"},
      {y:yTop + (h+gap),        color:"rgba(251,113,133,.95)"},
      {y:yTop + 2*(h+gap),      color:"rgba(167,139,250,.95)"}
    ];

    ctx.save();
    for(const s of strips){
      ctx.fillStyle = s.color;
      ctx.fillRect(x0, s.y, w, h);
    }
    ctx.restore();
  }
};

function buildDailyTickCallbackSkipFirstDay(labels){
  const seenDays = new Set();
  let firstDay = null;
  return (value, index)=>{
    const iso = labels[index];
    if(!iso) return "";
    const dayStr = fmtESTDay(iso);
    if(firstDay === null) firstDay = dayStr;
    if(seenDays.has(dayStr)) return "";
    seenDays.add(dayStr);
    if(dayStr === firstDay) return "";
    return dayStr;
  };
}

function ensureTsChart(){
  if(tsChart) return;
  tsChart=new Chart($("tsChart"),{
    type:"line",
    data:{
      labels:[],
      datasets:[
        {
          label:"Observed (USGS water level)",
          data:[],
          borderWidth:2,
          pointRadius:0,
          tension:0.25,
          spanGaps:false,
          borderColor:"rgba(45,212,191,.9)",
          segment:{
            borderColor:(ctx)=>{
              const y = ctx?.p1?.parsed?.y;
              if(y===null || y===undefined || Number.isNaN(y)) return "rgba(45,212,191,.9)";
              return colorForFtDisplay(+y);
            }
          }
        },
        {
          label:"Predicted (NOAA)",
          data:[],
          borderWidth:2,
          pointRadius:0,
          tension:0.25,
          spanGaps:false,
          borderDash:[6,5],
          borderColor:"rgba(45,212,191,.9)",
          segment:{
            borderColor:(ctx)=>{
              const y = ctx?.p1?.parsed?.y;
              if(y===null || y===undefined || Number.isNaN(y)) return "rgba(45,212,191,.9)";
              return colorForFtDisplay(+y);
            }
          }
        }
      ]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{labels:{color:"rgba(234,240,255,.88)",font:{weight:"950"}}},
        tooltip:{
          callbacks:{
            title:(items)=>{
              if(!items || !items.length) return "";
              const iso = tsChart.data.labels[items[0].dataIndex];
              return fmtESTFull(iso);
            },
            label:(ctx)=>{
              const v = ctx.parsed?.y;
              const dsLabel = ctx.dataset?.label || "";
              if(v === null || v === undefined || Number.isNaN(v)) return dsLabel;
              return `${dsLabel}: ${(+v).toFixed(2)} ${datumLabel()}`;
            }
          }
        }
      },
      interaction:{mode:"index",intersect:false},
      scales:{
        x:{
          ticks:{
            color:"rgba(169,182,211,.9)",
            autoSkip:false,
            maxRotation:0,
            callback:()=>""
          },
          grid:{color:"rgba(255,255,255,.06)"}
        },
        y:{
          ticks:{color:"rgba(169,182,211,.9)"},
          grid:{color:"rgba(255,255,255,.06)"},
          title:{display:true,text:unitText(),color:"rgba(169,182,211,.9)",font:{weight:"950"}}
        }
      }
    },
    plugins:[floodStripPlugin]
  });
}

/* ========= END Part 1/2 ========= */
</script>

<script>
/* ========= SCRIPT (Part 2/2) ========= */

/* Peak counting uses NAVD thresholds */
function countFloodPeaks_NAVD(series){
  if(!series || series.length<3) return {minor:0, moderate:0, major:0};
  const T = THRESH.NAVD88;

  const pts = [...series].sort((a,b)=>new Date(a.t)-new Date(b.t));
  const candidates=[];

  for(let i=1;i<pts.length-1;i++){
    const a=pts[i-1], b=pts[i], c=pts[i+1];
    if(b.ft>=T.minorLow && b.ft>=a.ft && b.ft>=c.ft){
      if(!(b.ft===a.ft && b.ft===c.ft)) candidates.push(b);
    }
  }
  if(!candidates.length) return {minor:0, moderate:0, major:0};

  const minSepMs = PEAK_MIN_SEP_MINUTES*60*1000;
  const kept=[];
  let cur = candidates[0];
  for(let i=1;i<candidates.length;i++){
    const p=candidates[i];
    if(new Date(p.t)-new Date(cur.t) <= minSepMs){
      if(p.ft>cur.ft) cur=p;
    }else{
      kept.push(cur);
      cur=p;
    }
  }
  kept.push(cur);

  let minor=0, moderate=0, major=0;
  for(const p of kept){
    if(p.ft>=T.majorLow) major++;
    else if(p.ft>=T.moderateLow) moderate++;
    else minor++;
  }
  return {minor, moderate, major};
}

/* Annual counts from TXT */
function countAnnualFloodsFromTXT(eventsNavd){
  const T = THRESH.NAVD88;
  const byYear = new Map();
  for(const e of eventsNavd){
    const y = e.y || (new Date(e.t)).getUTCFullYear();
    if(!byYear.has(y)) byYear.set(y,{minor:0, moderate:0, major:0});
    if(e.ft >= T.minorLow){
      const rec = byYear.get(y);
      if(e.ft >= T.majorLow) rec.major++;
      else if(e.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }
  return byYear;
}

function buildAnnualArraysFromTXT_completedYears(){
  const {y:curYear}=getESTParts(new Date());

  if(!HIGH_TIDES_NAVD || !HIGH_TIDES_NAVD.length){
    YEARS=[]; annualMinor=[]; annualModerate=[]; annualMajor=[];
    return;
  }

  const byYear = countAnnualFloodsFromTXT(HIGH_TIDES_NAVD);
  const years = Array.from(byYear.keys()).sort((a,b)=>a-b);
  if(!years.includes(curYear)) years.push(curYear);

  YEARS = years;
  annualMinor = YEARS.map(y=> byYear.get(y)?.minor ?? 0);
  annualModerate = YEARS.map(y=> byYear.get(y)?.moderate ?? 0);
  annualMajor = YEARS.map(y=> byYear.get(y)?.major ?? 0);
}

function overwriteCurrentYearBarWithLiveCounts(liveCounts){
  if(!liveCounts) return;
  const {y:curYear}=getESTParts(new Date());
  const idx = YEARS.indexOf(curYear);
  if(idx < 0) return;
  annualMinor[idx] = liveCounts.minor;
  annualModerate[idx] = liveCounts.moderate;
  annualMajor[idx] = liveCounts.major;
}

/* Annual chart */
function ensureAnnual(){
  if(annualChart) return;
  annualChart=new Chart($("annualChart"),{
    type:"bar",
    data:{
      labels:YEARS,
      datasets:[
        {label:"Minor",data:annualMinor,stack:"f",borderWidth:0,backgroundColor:"rgba(251,191,36,.85)"},
        {label:"Moderate",data:annualModerate,stack:"f",borderWidth:0,backgroundColor:"rgba(251,113,133,.80)"},
        {label:"Major",data:annualMajor,stack:"f",borderWidth:0,backgroundColor:"rgba(167,139,250,.80)"}
      ]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{
          position:"bottom",
          labels:{color:"rgba(234,240,255,.88)",font:{weight:"950"},boxWidth:16}
        }
      },
      scales:{
        x:{
          stacked:true,
          ticks:{color:"rgba(169,182,211,.9)",maxRotation:0,autoSkip:true,maxTicksLimit:7},
          grid:{color:"rgba(255,255,255,.06)"}
        },
        y:{
          stacked:true,
          ticks:{color:"rgba(169,182,211,.9)",precision:0},
          grid:{color:"rgba(255,255,255,.06)"}
        }
      }
    }
  });
}

function renderAnnual(){
  ensureAnnual();
  annualChart.data.labels = YEARS;
  annualChart.data.datasets[0].data = annualMinor;
  annualChart.data.datasets[1].data = annualModerate;
  annualChart.data.datasets[2].data = annualMajor;
  annualChart.update();
}

/* OBS vs PRED fixed axis */
function updateTsChartFromState(){
  if(!STATE.obs24Navd) STATE.obs24Navd = [];
  if(!STATE.pred72Mllw) STATE.pred72Mllw = [];

  const endISO = nowISO();
  const startISO = new Date(new Date(endISO).getTime() - 24*3600*1000).toISOString();

  const obsGrid = buildFixedGrid15Min(STATE.obs24Navd, startISO, endISO);
  const obsLabels = obsGrid.labels;
  const obsValsDisplay = obsGrid.values.map(v => (v===null ? null : toDisplayFtFromNavd(v)));

  const fcDisplayRaw = (STATE.pred72Mllw||[]).map(p=>({ t:p.t, ft:toDisplayFtFromMllw(p.ft) }));
  const fc15 = resampleTo15Min(fcDisplayRaw);

  const fcLabels = fc15.map(p=>p.t);
  const labels = [...obsLabels, ...fcLabels];

  const obsData = [...obsValsDisplay, ...Array(fcLabels.length).fill(null)];
  const fcData  = [...Array(obsLabels.length).fill(null), ...fc15.map(p=>p.ft)];

  ensureTsChart();
  tsChart.data.labels = labels;
  tsChart.data.datasets[0].data = obsData;
  tsChart.data.datasets[1].data = fcData;

  tsChart.options.scales.x.ticks.callback = buildDailyTickCallbackSkipFirstDay(labels);
  tsChart.options.scales.y.title.text = unitText();
  tsChart.update();
}

/* Historic filter from TXT */
function hydrateHistoricFromTXT(){
  HIGH_TIDES_NAVD = (DAILY_EVENTS_NAVD||[]).map(e=>({t:e.t, ft:e.ft, kind:e.kind, y:e.y, m:e.m, d:e.d}));
  HIGH_TIDES_NAVD.sort((a,b)=>new Date(b.t)-new Date(a.t));
  applyFilter();
  if(histMeta){
    histMeta.textContent = HIGH_TIDES_NAVD.length
      ? `Loaded ${HIGH_TIDES_NAVD.length.toLocaleString()} daily events from TXT (High + Low-High).`
      : "TXT loaded, but no daily events found.";
  }
}

function renderHist(rowsNavd){
  if(!histBody) return;
  histBody.innerHTML="";
  const show=rowsNavd.slice(0, 100);
  for(const r of show){
    const tag=stageTagByNavd(r.ft);
    const disp = toDisplayFtFromNavd(r.ft);
    const label = r.kind ? `${r.kind} · ` : "";
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${label}${fmtESTFull(r.t)}</td>
      <td><b>${disp.toFixed(2)}</b></td>
      <td><span class="tag"><span class="chip" style="background:${tag.c}"></span>${tag.txt}</span></td>
    `;
    histBody.appendChild(tr);
  }
  if(histMeta) histMeta.textContent=`Showing ${Math.min(100, rowsNavd.length)} of ${rowsNavd.length.toLocaleString()}`;
}

function applyFilter(){
  if(!minElevEl || !sortModeEl) return;
  const minDisplay=parseFloat(minElevEl.value);
  const minNavd = fromDisplayToNavd(minDisplay);
  const mode=sortModeEl.value;

  let rows=HIGH_TIDES_NAVD.filter(r=>r.ft>=minNavd);

  if(mode==="desc") rows.sort((a,b)=>b.ft-a.ft);
  if(mode==="asc") rows.sort((a,b)=>a.ft-b.ft);
  if(mode==="recent") rows.sort((a,b)=>new Date(b.t)-new Date(a.t));

  renderHist(rows);
}

/* Monthly averages */
function monthNameFromIndex(i){
  const d = new Date(Date.UTC(2020, i-1, 15, 0, 0, 0));
  return fmtMonthName.format(d);
}

function computeMonthlyAveragesFromEvents(eventsNavd){
  const T = THRESH.NAVD88;
  const byYearMonth = new Map();
  const yearsSet = new Set();

  for(const p of eventsNavd){
    let y = p.y, m = p.m;
    if(!y || !m){
      const dt = new Date(p.t);
      if(Number.isNaN(dt.getTime())) continue;
      y = dt.getUTCFullYear();
      m = dt.getUTCMonth()+1;
    }
    yearsSet.add(y);

    const key = `${y}-${m}`;
    if(!byYearMonth.has(key)){
      byYearMonth.set(key,{year:y, month:m, total:0, minor:0, moderate:0, major:0});
    }
    const rec = byYearMonth.get(key);

    if(p.ft >= T.minorLow){
      rec.total++;
      if(p.ft >= T.majorLow) rec.major++;
      else if(p.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }

  const years = Array.from(yearsSet).sort((a,b)=>a-b);
  const result = [];

  for(let m=1;m<=12;m++){
    const rowsForMonth=[];
    for(const y of years){
      const key = `${y}-${m}`;
      rowsForMonth.push(byYearMonth.get(key) || {year:y, month:m, total:0, minor:0, moderate:0, major:0});
    }
    const n = rowsForMonth.length || 1;
    const sum = rowsForMonth.reduce((acc,r)=>{
      acc.total += r.total;
      acc.minor += r.minor;
      acc.moderate += r.moderate;
      acc.major += r.major;
      return acc;
    },{total:0, minor:0, moderate:0, major:0});

    result.push({
      month:m,
      avgTotal: sum.total / n,
      avgMinor: sum.minor / n,
      avgModerate: sum.moderate / n,
      avgMajor: sum.major / n,
      years:n
    });
  }
  return result;
}

function renderMonthAveragesTable(monthStats){
  if(!monthAvgBody) return;
  monthAvgBody.innerHTML="";
  for(const r of monthStats){
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><b>${monthNameFromIndex(r.month)}</b></td>
      <td>${r.avgTotal.toFixed(2)}</td>
      <td>${r.avgMinor.toFixed(2)}</td>
      <td>${r.avgModerate.toFixed(2)}</td>
      <td>${r.avgMajor.toFixed(2)}</td>
    `;
    monthAvgBody.appendChild(tr);
  }
}

function ensureMonthAvgChart(){
  if(monthAvgChart) return;
  monthAvgChart = new Chart($("monthAvgChart"),{
    type:"bar",
    data:{ labels:[], datasets:[
      {label:"Avg Minor", data:[], stack:"m", borderWidth:0, backgroundColor:"rgba(251,191,36,.85)"},
      {label:"Avg Moderate", data:[], stack:"m", borderWidth:0, backgroundColor:"rgba(251,113,133,.80)"},
      {label:"Avg Major", data:[], stack:"m", borderWidth:0, backgroundColor:"rgba(167,139,250,.80)"}
    ]},
    options:{
      responsive:true,
      maintainAspectRatio:false,
      plugins:{ legend:{position:"bottom",labels:{color:"rgba(234,240,255,.88)",font:{weight:"950"},boxWidth:16}} },
      scales:{
        x:{stacked:true,ticks:{color:"rgba(169,182,211,.9)"},grid:{color:"rgba(255,255,255,.06)"}},
        y:{stacked:true,ticks:{color:"rgba(169,182,211,.9)"},grid:{color:"rgba(255,255,255,.06)"}}
      }
    }
  });
}

function renderMonthAveragesChart(monthStats){
  ensureMonthAvgChart();
  monthAvgChart.data.labels = monthStats.map(r=>monthNameFromIndex(r.month));
  monthAvgChart.data.datasets[0].data = monthStats.map(r=>r.avgMinor);
  monthAvgChart.data.datasets[1].data = monthStats.map(r=>r.avgModerate);
  monthAvgChart.data.datasets[2].data = monthStats.map(r=>r.avgMajor);
  monthAvgChart.update();
}

function updateMonthAveragesFromTXT(){
  if(!HIGH_TIDES_NAVD.length){
    if(monthAvgMeta) monthAvgMeta.textContent="No TXT daily events loaded yet.";
    const zeros = Array.from({length:12},(_,i)=>({month:i+1,avgTotal:0,avgMinor:0,avgModerate:0,avgMajor:0,years:0}));
    renderMonthAveragesTable(zeros);
    renderMonthAveragesChart(zeros);
    return;
  }
  const stats = computeMonthlyAveragesFromEvents(HIGH_TIDES_NAVD);
  if(monthAvgMeta) monthAvgMeta.textContent = `Averages across ${stats[0]?.years ?? 0} years (computed from TXT daily High + Low-High events).`;
  renderMonthAveragesTable(stats);
  renderMonthAveragesChart(stats);
}

/* LIVE */
async function updateLiveAndAnnualCounts(){
  buildAnnualArraysFromTXT_completedYears();
  renderAnnual();

  const {y:curYear}=getESTParts(new Date());
  const startISO = startOfYearEST_ISO(curYear);
  const endISO = nowISO();

  const ytd = await fetchObservedSeries({startISO, endISO});
  if(!ytd.length) throw new Error("no live water-level data returned from USGS");

  STATE.ytdNavd = ytd;
  STATE.lastNavd = ytd[ytd.length-1];

  const curDisp = toDisplayFtFromNavd(STATE.lastNavd.ft);
  if(curFtEl) curFtEl.textContent = curDisp.toFixed(2);
  if(curMetaEl) curMetaEl.textContent = "Updated: " + fmtESTFull(STATE.lastNavd.t);
  if(lastPill) lastPill.textContent = "Last updated: " + fmtESTFull(STATE.lastNavd.t);

  setStage(STATE.lastNavd.ft);

  const today = sliceAfter(ytd, startOfTodayEST_ISO());
  STATE.todayNavd = today;
  if(today.length){
    const dmx=maxPoint(today), dmn=minPoint(today);
    if(dayMaxFtEl) dayMaxFtEl.textContent = toDisplayFtFromNavd(dmx.ft).toFixed(2);
    if(dayMinFtEl) dayMinFtEl.textContent = toDisplayFtFromNavd(dmn.ft).toFixed(2);
    if(dayRangeMeta) dayRangeMeta.textContent = `Max @ ${fmtESTFull(dmx.t)} · Min @ ${fmtESTFull(dmn.t)}`;
  }else{
    if(dayMaxFtEl) dayMaxFtEl.textContent="—";
    if(dayMinFtEl) dayMinFtEl.textContent="—";
    if(dayRangeMeta) dayRangeMeta.textContent="—";
  }

  const counts = countFloodPeaks_NAVD(ytd);
  overwriteCurrentYearBarWithLiveCounts(counts);
  renderAnnual();
}

/* Timeseries update */
async function updateTimeseries(){
  const end = new Date();
  const start = new Date(end.getTime() - 24*3600*1000);

  const obs = await fetchObservedSeries({startISO:start.toISOString(), endISO:end.toISOString()});
  STATE.obs24Navd = obs;

  const lastObsTime = obs.length ? obs[obs.length-1].t : null;

  try{
    const fc = await fetchCOOPSPredictions_MLLW({beginDateISO:lastObsTime || new Date().toISOString(), hours:72});
    STATE.pred72Mllw = fc;
    if(fcNote) fcNote.textContent = fc.length ? "" : "NOAA predictions returned no points.";
  }catch(e){
    STATE.pred72Mllw = [];
    if(fcNote) fcNote.textContent = `NOAA predictions unavailable: ${e?.message || String(e)}`;
  }

  updateTsChartFromState();
}

/* Init TXT-backed history */
async function initTXTBackedHistory(){
  await loadDailyTidesFromTXT();
  hydrateHistoricFromTXT();
  updateMonthAveragesFromTXT();
  buildAnnualArraysFromTXT_completedYears();
  renderAnnual();
}

/* Boot */
async function boot(){
  updateUnitsAndBadges();
  renderTopTen();

  const results = await Promise.allSettled([
    updateAlerts(),
    initTXTBackedHistory(),
    updateLiveAndAnnualCounts(),
    updateTimeseries()
  ]);

  if(results[1].status==="rejected"){
    console.error("TXT init failed:", results[1].reason);
    if(histMeta){
      histMeta.textContent =
        "TXT load failed. Ensure file is committed at data/daily_tides_navd88.txt (case-sensitive). See TXT status line.";
    }
    if(monthAvgMeta){
      monthAvgMeta.textContent =
        "TXT load failed (monthly averages unavailable). See TXT status line.";
    }
  }
  if(results[2].status==="rejected"){
    console.error("Live init failed:", results[2].reason);
    if(stageTextEl) stageTextEl.textContent="LIVE DATA UNAVAILABLE";
    if(lastPill) lastPill.textContent="Last updated: —";
    if(curFtEl) curFtEl.textContent="—";
    if(curMetaEl) curMetaEl.textContent="Updated: —";
  }
}

/* Controls */
const applyBtn = $("applyBtn");
if (applyBtn) applyBtn.addEventListener("click", applyFilter);

const resetBtn = $("resetBtn");
if (resetBtn) resetBtn.addEventListener("click", ()=>{
  if(minElevEl) minElevEl.value = THRESH[DISPLAY_DATUM].minorLow.toFixed(2);
  if(sortModeEl) sortModeEl.value="desc";
  applyFilter();
});

if (datumBtn) datumBtn.addEventListener("click", ()=>{
  const oldDatum = DISPLAY_DATUM;
  const v = parseFloat(minElevEl?.value);

  if(Number.isFinite(v)){
    const navd = (oldDatum==="MLLW") ? mllwToNavd(v) : v;
    DISPLAY_DATUM = (DISPLAY_DATUM==="MLLW") ? "NAVD88" : "MLLW";
    const newDisplayVal = (DISPLAY_DATUM==="MLLW") ? navdToMllw(navd) : navd;
    if(minElevEl) minElevEl.value = newDisplayVal.toFixed(2);
  }else{
    DISPLAY_DATUM = (DISPLAY_DATUM==="MLLW") ? "NAVD88" : "MLLW";
    if(minElevEl) minElevEl.value = THRESH[DISPLAY_DATUM].minorLow.toFixed(2);
  }

  updateUnitsAndBadges();
  renderTopTen();
  applyFilter();
  updateMonthAveragesFromTXT();
  renderAnnual();

  if(STATE.lastNavd){
    if(curFtEl) curFtEl.textContent = toDisplayFtFromNavd(STATE.lastNavd.ft).toFixed(2);
    setStage(STATE.lastNavd.ft);
  }
  if(STATE.todayNavd && STATE.todayNavd.length){
    const dmx=maxPoint(STATE.todayNavd), dmn=minPoint(STATE.todayNavd);
    if(dayMaxFtEl) dayMaxFtEl.textContent = toDisplayFtFromNavd(dmx.ft).toFixed(2);
    if(dayMinFtEl) dayMinFtEl.textContent = toDisplayFtFromNavd(dmn.ft).toFixed(2);
  }
  updateTsChartFromState();
});

/* Start + auto-refresh */
boot().catch(err=>{
  console.error(err);
  if(stageTextEl) stageTextEl.textContent="LIVE DATA UNAVAILABLE";
  if(lastPill) lastPill.textContent="Last updated: —";
});

setInterval(()=>boot().catch(()=>{}), 5*60*1000);

/* ========= END Part 2/2 ========= */
</script>
